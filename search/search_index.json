{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuCPL Documentation","text":"<p>Welcome to the QuCPL Documentation \u2014 the official guide for using, understanding, and contributing to the Quantum Computing Programming Language.</p> <p>QuCPL is a domain-specific language (DSL) built on Python, designed for educational and research purposes. It combines custom syntax, a parser/compiler system, quantum circuit simulation, and a GUI application for an intuitive and visual approach to quantum programming.</p>"},{"location":"#what-is-quantum-computing","title":"\ud83d\udd2d What is Quantum Computing?","text":"<p>Quantum computing is a transformative field of computing that leverages the principles of quantum mechanics to perform operations on data. Unlike classical computers, which use binary bits (<code>0</code> or <code>1</code>), quantum computers use qubits that can exist in superpositions of states, allowing them to process vast combinations of possibilities simultaneously.</p> <p>Quantum computers can solve certain problems exponentially faster than classical ones \u2014 such as factoring large numbers (Shor\u2019s algorithm), searching unsorted databases (Grover\u2019s algorithm), and simulating quantum systems in physics, chemistry, and cryptography.</p>"},{"location":"#what-is-a-qubit","title":"\ud83e\udde0 What is a Qubit?","text":"<p>A qubit (quantum bit) is the fundamental unit of quantum information. It can be in the state <code>|0\u27e9</code>, <code>|1\u27e9</code>, or any complex linear combination:</p> <pre><code>|\u03c8\u27e9 = \u03b1|0\u27e9 + \u03b2|1\u27e9\n</code></pre> <p>Where:</p> <ul> <li><code>\u03b1</code> and <code>\u03b2</code> are complex probability amplitudes</li> <li><code>|\u03b1|\u00b2 + |\u03b2|\u00b2 = 1</code></li> <li>The state collapses to either <code>|0\u27e9</code> or <code>|1\u27e9</code> upon measurement</li> </ul> <p>Qubits can also be entangled, meaning their states are correlated no matter the physical distance between them \u2014 a crucial property for quantum teleportation and quantum communication.</p>"},{"location":"#introducing-qucpl","title":"\ud83d\udcbb Introducing QuCPL","text":"<p>QuCPL (Quantum Computing Programming Language) is an educational-friendly quantum language designed to simplify quantum programming. It features:</p> <ul> <li>A readable syntax inspired by C/Python</li> <li>A custom compiler that outputs an intermediate JSON representation</li> <li>A simulator built on Qiskit</li> <li>A GUI studio with tabs for writing, simulating, and visualizing circuits</li> </ul> <p>QuCPL abstracts the complexity of backend circuit manipulation and allows users to focus on algorithmic thinking and quantum logic.</p>"},{"location":"#what-youll-find-in-this-documentation","title":"\ud83d\udce6 What You'll Find in This Documentation","text":"<p>This site is structured to help you get started with QuCPL and dive deep into its components:</p> <ul> <li>\ud83d\udcd8 Language Reference: Syntax, gates, measurement rules</li> <li>\u270d\ufe0f Writing QuCPL Programs: Sample code and real examples</li> <li>\ud83d\udcd0 Grammar &amp; Parser: The PEG grammar used and parsing pipeline</li> <li>\ud83d\udee0\ufe0f Compiler: AST to IR translation and IR schema</li> <li>\ud83d\udcca Visualization &amp; Simulation: How results are generated and displayed</li> <li>\ud83d\udda5\ufe0f GUI Application: Interface features and usage</li> <li>\ud83d\udcbe Outputs Explained: All exportable files and formats</li> <li>\ud83d\udca1 Developer Notes: Internal architecture and contribution tips</li> </ul> <p>Use the navigation bar to explore each section in depth. Whether you're a student, educator, or enthusiast, QuCPL is your gateway to practical quantum programming.</p> <p>Happy coding, and welcome to the quantum era! \u2728</p> <p>run mkdocs: mkdocs serve</p>"},{"location":"ast/","title":"Ast","text":""},{"location":"ast/#ast-examples","title":"AST Examples","text":"<p>The Abstract Syntax Tree (AST) is the structured representation generated after parsing a <code>.qucpl</code> file. This tree retains the syntactic structure of the source code and serves as the input to the QuCPL compiler.</p> <p>Below are AST examples for three common quantum programs:</p>"},{"location":"ast/#bell_astjson","title":"<code>bell_ast.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"body\": [\n    {\"type\": \"QubitDeclaration\", \"qubits\": [\"q0\", \"q1\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"H\", \"args\": [\"q0\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"CX\", \"args\": [\"q0\", \"q1\"]},\n    {\"type\": \"Measurement\", \"qubit\": \"q0\", \"target\": \"c0\"},\n    {\"type\": \"Measurement\", \"qubit\": \"q1\", \"target\": \"c1\"}\n  ]\n}\n</code></pre>"},{"location":"ast/#ghz_astjson","title":"<code>ghz_ast.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"body\": [\n    {\"type\": \"QubitDeclaration\", \"qubits\": [\"q0\", \"q1\", \"q2\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"H\", \"args\": [\"q0\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"CX\", \"args\": [\"q0\", \"q1\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"CX\", \"args\": [\"q0\", \"q2\"]},\n    {\"type\": \"Measurement\", \"qubit\": \"q0\", \"target\": \"c0\"},\n    {\"type\": \"Measurement\", \"qubit\": \"q1\", \"target\": \"c1\"},\n    {\"type\": \"Measurement\", \"qubit\": \"q2\", \"target\": \"c2\"}\n  ]\n}\n</code></pre>"},{"location":"ast/#teleportation_astjson","title":"<code>teleportation_ast.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"body\": [\n    {\"type\": \"QubitDeclaration\", \"qubits\": [\"q0\", \"q1\", \"q2\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"H\", \"args\": [\"q1\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"CX\", \"args\": [\"q1\", \"q2\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"CX\", \"args\": [\"q0\", \"q1\"]},\n    {\"type\": \"GateOperation\", \"gate\": \"H\", \"args\": [\"q0\"]},\n    {\"type\": \"Measurement\", \"qubit\": \"q0\", \"target\": \"c0\"},\n    {\"type\": \"Measurement\", \"qubit\": \"q1\", \"target\": \"c1\"}\n  ]\n}\n</code></pre> <p>Each AST object contains:</p> <ul> <li><code>QubitDeclaration</code>: Declares one or more quantum registers</li> <li><code>GateOperation</code>: Describes a single- or multi-qubit gate</li> <li><code>Measurement</code>: Maps quantum measurements to classical bits</li> </ul> <p>These JSON structures are saved to <code>ast.json</code> by the parser and passed to the compiler for IR generation.</p>"},{"location":"compiler/","title":"Compiler","text":"<p>The compiler walks the AST and generates a JSON intermediate representation:</p> <p>Walks AST and generates IR</p> <p>JSON-based IR design follows schema from ir_schema_docs.md</p> <p>Clear separation of instructions and control_flow blocks</p> <p>From compiler.ipynb:</p> <pre><code>import json\n\ndef flatten(lst):\n    if isinstance(lst, list):\n        result = []\n        for item in lst:\n            if isinstance(item, list):\n                result.extend(flatten(item))\n            else:\n                result.append(item)\n        return result\n    return [lst]\n\ndef compile_stmt(stmt):\n    stype = stmt[\"type\"]\n\n    if stype == \"QubitDecl\":\n        return (\"qubits\", flatten(stmt[\"qubits\"]))\n\n    elif stype == \"QuantumOp\":\n        return {\n            \"op\": stmt[\"gate\"],\n            \"args\": flatten(stmt[\"qubits\"])\n        }\n\n    elif stype == \"Measure\":\n        return {\n            \"op\": \"measure\",\n            \"qubits\": flatten(stmt[\"qubits\"]),\n            \"classical\": flatten(stmt[\"classical\"])\n        }\n\n    elif stype == \"Print\":\n        return {\n            \"op\": \"print\",\n            \"args\": flatten(stmt[\"args\"])\n        }\n\n    elif stype == \"If\":\n        return {\n            \"type\": \"if\",\n            \"condition\": stmt[\"condition\"],\n            \"then\": [compile_stmt(stmt[\"then\"])],\n            \"else\": [compile_stmt(stmt[\"else\"])] if stmt[\"else\"] else []\n        }\n\n    else:\n        raise ValueError(f\"Unknown statement type: {stype}\")\n\ndef ast_to_ir(ast):\n    ir = {\n        \"type\": \"Program\",\n        \"qubits\": [],\n        \"instructions\": [],\n        \"control_flow\": []\n    }\n\n    for stmt in ast[\"body\"]:\n        compiled = compile_stmt(stmt)\n        if isinstance(compiled, tuple) and compiled[0] == \"qubits\":\n            ir[\"qubits\"].extend(compiled[1])\n        elif isinstance(compiled, dict) and \"op\" in compiled:\n            ir[\"instructions\"].append(compiled)\n        elif isinstance(compiled, dict) and \"type\" in compiled:\n            ir[\"control_flow\"].append(compiled)\n\n    return ir\n\nif __name__ == \"__main__\":\n    with open(\"teleportation_ast.json\") as f:\n        ast = json.load(f)\n\n    ir = ast_to_ir(ast)\n\n    with open(\"teleportation_ir.json\", \"w\") as f:\n        json.dump(ir, f, indent=2)\n\n    print(\"IR saved to teleportation_ir.json\")\n</code></pre>"},{"location":"developer_note/","title":"Developer Notes","text":"<p>Compiler: compiler.py \u2192 IR</p> <p>Visualization: visualize.py -&gt; circuit image</p> <p>Simulator: simulation.py \u2192 Qiskit backend</p> <p>GUI: final_app.py</p> <p>Future enhancements:</p> <p>OpenQASM export</p> <p>Autocomplete</p> <p>Formal verification</p> <p>Language server protocol integration</p>"},{"location":"examples/","title":"Example Programs","text":"<p>bell.qucpl :</p> <pre><code>qubit q0, q1;\nH q0;\nCX q0, q1;\nmeasure q0 -&gt; c0;\nmeasure q1 -&gt; c1;\n</code></pre> <p>ghz.qucpl:</p> <pre><code>qubit q0, q1, q2;\nH q0;\nCX q0, q1;\nCX q0, q2;\nmeasure q0 -&gt; c0;\nmeasure q1 -&gt; c1;\nmeasure q2 -&gt; c2;\n</code></pre> <p>teleportation.qucpl:</p> <pre><code>qubit q0, q1, q2;\nqop h q1;\nqop cx q1, q2;\nqop cx q0, q1;\nqop h q0;\nmeasure q0, q1 -&gt; c0, c1;\nif (c1 == 1) {\n  qop x q2;\n}\nif (c0 == 1) {\n  qop z q2;\n}\nprint q2;\n</code></pre>"},{"location":"grammar/","title":"Grammar","text":"<p>QuCPL uses Lark (PEG) to define its grammar.</p> <p>PEG-style rule definitions</p> <p>Supports declarations, gates, and measurement</p> <p>Useful for contributors extending the syntax</p> <p>Directly from grammar.lark:</p> <pre><code>?start: stmt+\n\n?stmt: qubit_decl \";\"\n     | qop_stmt \";\"\n     | measure_stmt \";\"\n     | print_stmt \";\"\n     | if_stmt\n\nqubit_decl: \"qubit\" id_list\nqop_stmt: \"qop\" GATE_NAME id_list\nmeasure_stmt: \"measure\" id_list \"-&gt;\" id_list\nprint_stmt: \"print\" id_list\n\nif_stmt: \"if\" \"(\" condition \")\" \"{\" stmt+ \"}\" (\"else\" \"{\" stmt+ \"}\")?\n\ncondition: CNAME \"==\" INT\n\nid_list: CNAME (\",\" CNAME)*\n\nGATE_NAME: \"h\" | \"x\" | \"y\" | \"z\" | \"cx\" | \"cz\" | \"ccx\" | \"swap\" | \"cy\"\n\n%import common.CNAME\n%import common.INT\n%import common.WS\n%ignore WS\n\n</code></pre>"},{"location":"gui_app/","title":"GUI Application","text":"<p>Launched via: python final_app.py</p> <p>Features: Code editor, Run button, Tabs for Circuit(AST, IR, Simulation, Circuit, Bloch), Statevector, Histogram, Bloch, Export buttons, Error logs, status messages and Scrollable logging window.</p> <p>From final_app.py:</p> <pre><code># Enhanced app.py for QuCPL Studio with all requested features\n\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox, scrolledtext, ttk\nimport os, json, re\nfrom parser import parse_qucpl\nfrom compiler import ast_to_ir\nfrom simulation import simulate, build_qiskit_circuit\nfrom visualize import visualize_circuit\nfrom qiskit.quantum_info import Statevector, partial_trace\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nimport matplotlib.pyplot as plt\nimport keyword\n\ntry:\n    from qiskit_aer import AerSimulator\n    from qiskit.visualization.timeline import draw as timeline_drawer\n    from qiskit import transpile\nexcept ImportError:\n    AerSimulator = None\n    timeline_drawer = None\n\nQUCPL_KEYWORDS = [\"h\", \"x\", \"cx\", \"ccx\", \"measure\", \"reset\", \"barrier\", \"if\", \"for\", \"module\", \"return\", \"let\"]\nQUCPL_SNIPPETS = {\n    \"if\": \"if condition {\\n    // code\\n}\",\n    \"for\": \"for i in 0..N {\\n    // code\\n}\",\n    \"module\": \"module name(args) {\\n    // body\\n}\"\n}\n\nclass QuCPLStudio:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"QuCPL Studio \u2013 Quantum IDE\")\n        self.root.geometry(\"1400x900\")\n        self.save_dir = os.getcwd()\n        self.ast = None\n        self.ir = None\n        self.code = \"\"\n        self.ast_path = \"ast.json\"\n        self.ir_path = \"ir.json\"\n        self.create_widgets()\n\n    def create_widgets(self):\n        self.code_area = scrolledtext.ScrolledText(self.root, font=(\"Consolas\", 12), wrap=tk.WORD, height=14, undo=True)\n        self.code_area.pack(fill=tk.BOTH, expand=True)\n        self.code_area.bind(\"&lt;Tab&gt;\", self.on_tab_autocomplete)\n        self.code_area.bind(\"&lt;KeyRelease&gt;\", self.highlight_keywords)\n\n        btn_frame = tk.Frame(self.root)\n        btn_frame.pack(fill=tk.X)\n        for text, cmd in [\n            (\"Open\", self.load_code),\n            (\"Save\", self.save_code),\n            (\"Set Output Dir\", self.set_save_dir),\n            (\"Parse\", self.parse_code),\n            (\"Compile\", self.compile_ir),\n            (\"Visualize\", self.plot_visualization),\n            (\"Simulate\", self.simulate_and_display),\n            (\"Statevector\", self.show_statevector),\n            (\"Reset\", self.reset_app),\n            (\"Export AST/IR\", self.export_ast_ir)\n        ]:\n            tk.Button(btn_frame, text=text, command=cmd).pack(side=tk.LEFT, padx=4, pady=4)\n\n        # Main vertical split: Tabs + Logging Console\n        main_pane = tk.PanedWindow(self.root, orient=tk.VERTICAL)\n        main_pane.pack(fill=tk.BOTH, expand=True)\n\n        # Tabs section\n        paned = tk.PanedWindow(main_pane, orient=tk.VERTICAL)\n        self.tabs = ttk.Notebook(paned)\n        self.ast_view = scrolledtext.ScrolledText(self.tabs, font=(\"Courier\", 11))\n        self.ir_view = scrolledtext.ScrolledText(self.tabs, font=(\"Courier\", 11))\n        self.plot_frame = tk.Frame(self.tabs)\n        self.sim_frame = tk.Frame(self.tabs)\n        self.state_frame = tk.Frame(self.tabs)\n        self.bloch_frame = tk.Frame(self.tabs)\n        self.help_view = scrolledtext.ScrolledText(self.tabs, font=(\"Consolas\", 11))\n\n        for frame, label in [\n            (self.ast_view, \"AST\"),\n            (self.ir_view, \"IR\"),\n            (self.plot_frame, \"Visuals\"),\n            (self.sim_frame, \"Simulation Output\"),\n            (self.state_frame, \"Statevector\"),\n            (self.bloch_frame, \"Bloch Spheres\"),\n            (self.help_view, \"Help\")\n        ]:\n            self.tabs.add(frame, text=label)\n        paned.add(self.tabs)\n\n        # Logging Console (Resizable)\n        self.log_area = scrolledtext.ScrolledText(main_pane, height=6, bg=\"#111\", fg=\"lime\", font=(\"Courier\", 10))\n\n        main_pane.add(paned)\n        main_pane.add(self.log_area)\n\n        # Tutorial and View Controls\n        ctrl_frame = tk.Frame(self.root)\n        ctrl_frame.pack(fill=tk.X)\n        tk.Label(ctrl_frame, text=\"Tutorial:\").pack(side=tk.LEFT)\n        self.tutorial_option = tk.StringVar(value=\"None\")\n        tutorials = [\"None\", \"Bell\", \"GHZ\", \"Teleport\"]\n        tk.OptionMenu(ctrl_frame, self.tutorial_option, *tutorials, command=self.load_tutorial).pack(side=tk.LEFT)\n\n        tk.Label(ctrl_frame, text=\"View:\").pack(side=tk.LEFT)\n        self.view_option = tk.StringVar(value=\"Circuit\")\n        views = [\"Circuit\", \"Histogram\", \"Bloch\", \"Timeline\", \"Density\", \"Entanglement\"]\n        tk.OptionMenu(ctrl_frame, self.view_option, *views).pack(side=tk.LEFT)\n\n        self.load_help_doc()\n\n    def log(self, msg):\n        print(msg)\n        self.log_area.insert(tk.END, msg + \"\\n\")\n        self.log_area.see(tk.END)\n\n    def load_help_doc(self):\n        self.help_view.delete(\"1.0\", tk.END)\n        self.help_view.insert(tk.END, \"\"\"\nWelcome to QuCPL Studio!\n=========================\n\nSteps:\n1. Write code or load a tutorial.\n2. Click Parse to generate AST.\n3. Click Compile to convert to IR.\n4. Click Visualize or Simulate to view.\n5. Use dropdowns for tutorials or views.\n\nKeywords:\n  - let, if, for, module, return\nGates:\n  - h, x, cx, ccx, reset, barrier\nMeasurement:\n  - measure q0 -&gt; c0\n\nViews:\n  - Circuit: Standard diagram\n  - Histogram: Output probabilities\n  - Bloch: Visualize qubit states\n  - Timeline: Gate scheduling\n  - Density: Matrix visualization\n  - Entanglement: Inter-qubit entanglement heatmap\n\nTutorials:\n  Bell, GHZ, Quantum Teleportation\n\"\"\")\n\n    def load_tutorial(self, value):\n        samples = {\n            \"Bell\": \"let q0, q1, c0, c1\\nh q0\\ncx q0 q1\\nmeasure q0 -&gt; c0\\nmeasure q1 -&gt; c1\",\n            \"GHZ\": \"let q0, q1, q2, c0, c1, c2\\nh q0\\ncx q0 q1\\ncx q1 q2\\nmeasure q0 -&gt; c0\\nmeasure q1 -&gt; c1\\nmeasure q2 -&gt; c2\",\n            \"Teleport\": \"let q0, q1, q2, c0, c1\\nh q1\\ncx q1 q2\\ncx q0 q1\\nh q0\\nmeasure q0 -&gt; c0\\nmeasure q1 -&gt; c1\\nif c0 == 1 { x q2 }\\nif c1 == 1 { z q2 }\"\n        }\n        if value in samples:\n            self.code_area.delete(\"1.0\", tk.END)\n            self.code_area.insert(tk.END, samples[value])\n            self.log(f\"[\ud83d\udcda TUTORIAL LOADED] {value} example\")\n\n    def load_code(self):\n        path = filedialog.askopenfilename()\n        if path:\n            with open(path) as f:\n                self.code_area.delete(\"1.0\", tk.END)\n                self.code_area.insert(tk.END, f.read())\n            self.log(f\"[OPENED] {path}\")\n\n    def save_code(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".qucpl\")\n        if path:\n            with open(path, \"w\") as f:\n                f.write(self.code_area.get(\"1.0\", tk.END))\n            self.log(f\"[SAVED] {path}\")\n\n    def set_save_dir(self):\n        dir_ = filedialog.askdirectory()\n        if dir_:\n            self.save_dir = dir_\n            self.ast_path = os.path.join(dir_, \"ast.json\")\n            self.ir_path = os.path.join(dir_, \"ir.json\")\n            self.log(f\"[DIR SET] Output: {dir_}\")\n\n    def parse_code(self):\n        try:\n            code = self.code_area.get(\"1.0\", tk.END).strip()\n            self.ast = parse_qucpl(code)\n            with open(self.ast_path, \"w\") as f:\n                json.dump(self.ast, f, indent=2)\n            self.ast_view.delete(\"1.0\", tk.END)\n            self.ast_view.insert(tk.END, json.dumps(self.ast, indent=2))\n            self.log(\"[\u2705 PARSED] AST generated\")\n        except Exception as e:\n            self.log(f\"[\u274c PARSE ERROR] {e}\")\n\n    def compile_ir(self):\n        try:\n            if not self.ast:\n                raise Exception(\"Parse first.\")\n            self.ir = ast_to_ir(self.ast)\n            with open(self.ir_path, \"w\") as f:\n                json.dump(self.ir, f, indent=2)\n            self.ir_view.delete(\"1.0\", tk.END)\n            self.ir_view.insert(tk.END, json.dumps(self.ir, indent=2))\n            self.log(\"[\u2705 COMPILED] IR generated\")\n        except Exception as e:\n            self.log(f\"[\u274c COMPILE ERROR] {e}\")\n\n    def export_ast_ir(self):\n        try:\n            if self.ast:\n                path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"ast.json\")\n                if path:\n                    with open(path, \"w\") as f:\n                        json.dump(self.ast, f, indent=2)\n                    self.log(f\"[\ud83d\udcbe AST SAVED] {path}\")\n            if self.ir:\n                path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"ir.json\")\n                if path:\n                    with open(path, \"w\") as f:\n                        json.dump(self.ir, f, indent=2)\n                    self.log(f\"[\ud83d\udcbe IR SAVED] {path}\")\n        except Exception as e:\n            self.log(f\"[\u274c EXPORT ERROR] {e}\")\n\n    def show_plot(self, fig, frame, save_name=\"circuit_output.png\"):\n        for w in frame.winfo_children():\n            w.destroy()\n        canvas = FigureCanvasTkAgg(fig, master=frame)\n        canvas.draw()\n        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n\n        tk.Button(frame, text=\"Save Image\", command=lambda: fig.savefig(save_name)).pack()\n\n\n    def show_sim_plot(self, fig, frame, save_name=\"simulation_histogram.png\"):\n        for w in frame.winfo_children():\n            w.destroy()\n        canvas = FigureCanvasTkAgg(fig, master=frame)\n        canvas.draw()\n        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n\n        tk.Button(frame, text=\"Save Image\", command=lambda: fig.savefig(save_name)).pack()\n\n    def simulate_and_display(self):\n        try:\n            if not self.ir:\n                raise Exception(\"Compile first.\")\n            simulate(self.ir_path, title=\"Simulation\")\n            qc, _ = build_qiskit_circuit(self.ir)\n            sim = AerSimulator()\n            tqc = transpile(qc, sim)\n            result = sim.run(tqc).result()\n            counts = result.get_counts()\n            fig = plot_histogram(counts)\n            self.show_sim_plot(fig, self.sim_frame)\n            self.log(\"[\u2699\ufe0f SIMULATED] Histogram displayed\")\n        except Exception as e:\n            self.log(f\"[\u274c SIM ERROR] {e}\")\n\n\n    def plot_visualization(self):\n        try:\n            if not self.ir:\n                raise Exception(\"Compile first.\")\n            qc, _ = build_qiskit_circuit(self.ir)\n            view = self.view_option.get()\n            fig = None\n            if view == \"Circuit\":\n                fig = qc.draw(output=\"mpl\")\n            elif view == \"Histogram\" and AerSimulator:\n                sim = AerSimulator()\n                tqc = transpile(qc, sim)\n                result = sim.run(tqc).result()\n                counts = result.get_counts()\n                fig = plot_histogram(counts)\n            elif view == \"Bloch\":\n                state = Statevector.from_instruction(qc)\n                fig = plot_bloch_multivector(state)\n            elif view == \"Timeline\" and timeline_drawer:\n                fig = timeline_drawer(qc)\n            elif view == \"Density\":\n                from qiskit.quantum_info import DensityMatrix\n                dm = DensityMatrix.from_instruction(qc)\n                fig, ax = plt.subplots()\n                ax.matshow(abs(dm.data), cmap='viridis')\n                ax.set_title(\"Density Matrix\")\n            elif view == \"Entanglement\":\n                import numpy as np\n                state = Statevector.from_instruction(qc)\n                n = state.num_qubits\n                fig, ax = plt.subplots()\n                ent = np.zeros((n, n))\n                for i in range(n):\n                    for j in range(n):\n                        if i != j:\n                            reduced = partial_trace(state, [k for k in range(n) if k != i and k != j])\n                            ent[i, j] = np.linalg.norm(reduced.data.real)\n                ax.imshow(ent, cmap='inferno')\n                ax.set_title(\"Entanglement Heatmap\")\n            if fig:\n                self.show_plot(fig, self.plot_frame)\n                self.log(f\"[\ud83d\udd0d VIEW] {view} shown\")\n        except Exception as e:\n            self.log(f\"[\u274c VIS ERROR] {e}\")\n\n    def show_statevector(self):\n        try:\n            for w in self.state_frame.winfo_children():\n                w.destroy()\n            for w in self.bloch_frame.winfo_children():\n                w.destroy()\n            qc, _ = build_qiskit_circuit(self.ir)\n            state = Statevector.from_instruction(qc)\n\n            text = tk.Text(self.state_frame, font=(\"Courier\", 12))\n            text.pack(fill=tk.BOTH, expand=True)\n            basis = [f\"|{i:0{state.num_qubits}b}&gt;\" for i in range(len(state))]\n            for i, amp in enumerate(state):\n                text.insert(tk.END, f\"{basis[i]}: {amp}\\n\")\n            tk.Button(self.state_frame, text=\"Save Text\", command=lambda: self.save_text_output(text, \"statevector.txt\")).pack()\n\n            fig = plot_bloch_multivector(state)\n            canvas = FigureCanvasTkAgg(fig, master=self.bloch_frame)\n            canvas.draw()\n            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n            tk.Button(self.bloch_frame, text=\"Save Bloch Image\", command=lambda: fig.savefig(\"bloch_sphere.png\")).pack()\n\n            self.log(\"[\ud83d\udcca STATEVECTOR &amp; BLOCH] Displayed\")\n        except Exception as e:\n            self.log(f\"[\u274c STATE ERROR] {e}\")\n\n    def save_text_output(self, widget, filename):\n        content = widget.get(\"1.0\", tk.END)\n        path = filedialog.asksaveasfilename(defaultextension=\".txt\", initialfile=filename)\n        if path:\n            with open(path, \"w\") as f:\n                f.write(content)\n            self.log(f\"[\ud83d\udcbe TEXT SAVED] {path}\")\n\n    def reset_app(self):\n        self.code_area.delete(\"1.0\", tk.END)\n        self.ast_view.delete(\"1.0\", tk.END)\n        self.ir_view.delete(\"1.0\", tk.END)\n        self.log_area.delete(\"1.0\", tk.END)\n        for f in [self.plot_frame, self.sim_frame, self.state_frame, self.bloch_frame]:\n            for w in f.winfo_children():\n                w.destroy()\n        self.log(\"[\ud83d\udd04 RESET] App state cleared\")\n\n    def on_tab_autocomplete(self, event):\n        pos = self.code_area.index(tk.INSERT)\n        word = self.code_area.get(\"insert-1c wordstart\", \"insert\")\n        snippet = QUCPL_SNIPPETS.get(word.strip())\n        if snippet:\n            self.code_area.insert(\"insert\", snippet[len(word):])\n            return \"break\"\n\n    def highlight_keywords(self, event=None):\n        self.code_area.tag_remove(\"keyword\", \"1.0\", tk.END)\n        for kw in QUCPL_KEYWORDS:\n            start = \"1.0\"\n            while True:\n                start = self.code_area.search(rf'\\m{kw}\\M', start, tk.END, regexp=True)\n                if not start:\n                    break\n                end = f\"{start}+{len(kw)}c\"\n                self.code_area.tag_add(\"keyword\", start, end)\n                start = end\n        self.code_area.tag_config(\"keyword\", foreground=\"blue\", font=(\"Consolas\", 12, \"bold\"))\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = QuCPLStudio(root)\n    root.mainloop()\n\n</code></pre>"},{"location":"ir/","title":"Ir","text":""},{"location":"ir/#ir-examples","title":"IR Examples","text":"<p>QuCPL's Intermediate Representation (IR) is a JSON format designed to bridge the parsed AST and quantum execution. It is backend-agnostic and can be interpreted by Qiskit or other simulators.</p>"},{"location":"ir/#bell_irjson","title":"<code>bell_ir.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"qubits\": [\"q0\", \"q1\"],\n  \"instructions\": [\n    {\"op\": \"h\", \"args\": [\"q0\"]},\n    {\"op\": \"cx\", \"args\": [\"q0\", \"q1\"]},\n    {\n      \"op\": \"measure\",\n      \"qubits\": [\"q0\", \"q1\"],\n      \"classical\": [\"c0\", \"c1\"]\n    }\n  ],\n  \"control_flow\": []\n}\n</code></pre>"},{"location":"ir/#ghz_irjson","title":"<code>ghz_ir.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"qubits\": [\"q0\", \"q1\", \"q2\"],\n  \"instructions\": [\n    {\"op\": \"h\", \"args\": [\"q0\"]},\n    {\"op\": \"cx\", \"args\": [\"q0\", \"q1\"]},\n    {\"op\": \"cx\", \"args\": [\"q0\", \"q2\"]},\n    {\n      \"op\": \"measure\",\n      \"qubits\": [\"q0\", \"q1\", \"q2\"],\n      \"classical\": [\"c0\", \"c1\", \"c2\"]\n    }\n  ],\n  \"control_flow\": []\n}\n</code></pre>"},{"location":"ir/#teleportation_irjson","title":"<code>teleportation_ir.json</code>","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"qubits\": [\"q0\", \"q1\", \"q2\"],\n  \"instructions\": [\n    {\"op\": \"h\", \"args\": [\"q1\"]},\n    {\"op\": \"cx\", \"args\": [\"q1\", \"q2\"]},\n    {\"op\": \"cx\", \"args\": [\"q0\", \"q1\"]},\n    {\"op\": \"h\", \"args\": [\"q0\"]},\n    {\n      \"op\": \"measure\",\n      \"qubits\": [\"q0\", \"q1\"],\n      \"classical\": [\"c0\", \"c1\"]\n    }\n  ],\n  \"control_flow\": []\n}\n</code></pre> <p>Each IR JSON includes:</p> <ul> <li><code>type</code>: Always <code>\"Program\"</code></li> <li><code>qubits</code>: List of named qubit registers</li> <li><code>instructions</code>: Gate applications and measurements</li> <li><code>control_flow</code>: Optional structures like <code>if</code>, <code>while</code></li> </ul> <p>These <code>.json</code> files are used by the simulator to build and execute circuits.</p>"},{"location":"language/","title":"Language Reference","text":"<p>Keywords: qubit, measure, H, X, Y, Z, CX, CCX, reset</p> <p>Includes:</p> <p>List of supported gate operations</p> <p>Basic QuCPL syntax with examples</p> <p>Comment style</p> <p>Clean, simple syntax like:</p> <pre><code>qubit q0, q1;\nH q0;\nCX q0, q1;\nmeasure q0 -&gt; c0;\nmeasure q1 -&gt; c1;\n</code></pre> <p>Comments: Use // for single-line comments.</p> <p>Classical Registers: Declare as needed: classical c0, c1;</p>"},{"location":"outputs/","title":"Outputs Explained","text":"<p>Files generated:</p> <p>ast.json \u2014 Parsed syntax tree by parser</p> <p>ir.json \u2014 Intermediate representation by compiler</p> <p>circuit.png, bloch.png, histogram.png \u2014 by visualizer/simulator</p>"},{"location":"parser/","title":"Parser","text":"<p>From parser.ipynb:</p> <p>Loads grammar.lark </p> <p>Parses source code \u2192 AST using Lark</p> <p>Saves as ast.json</p> <pre><code>from lark import Lark, Transformer, v_args\nimport json\n\nwith open(\"grammar.lark\") as f:\n    grammar = f.read()\n\nparser = Lark(grammar, parser='lalr', start='start')\n\n@v_args(inline=True)\nclass ASTBuilder(Transformer):\n    def start(self, *stmts): return {\"type\": \"Program\", \"body\": list(stmts)}\n\n    def qubit_decl(self, *ids): return {\"type\": \"QubitDecl\", \"qubits\": list(ids)}\n    def qop_stmt(self, gate, args): return {\"type\": \"QuantumOp\", \"gate\": gate, \"qubits\": args}\n\n    def measure_stmt(self, *args): \n        mid = len(args) // 2\n        return {\"type\": \"Measure\", \"qubits\": list(args[:mid]), \"classical\": list(args[mid:])}\n    def print_stmt(self, *args): return {\"type\": \"Print\", \"args\": list(args)}\n\n    def if_stmt(self, cond, *blocks):\n        if_block = blocks[0]\n        else_block = blocks[1] if len(blocks) &gt; 1 else None\n        return {\n            \"type\": \"If\",\n            \"condition\": cond,\n            \"then\": if_block,\n            \"else\": else_block\n        }\n\n    def condition(self, var, val):\n        return {\"type\": \"Condition\", \"var\": var, \"value\": int(val)}\n\n    def id_list(self, *args): return list(args)\n    def GATE_NAME(self, token): return str(token)\n    def CNAME(self, token): return str(token)\n    def INT(self, token): return int(token)\n    def stmt(self, stmt): return stmt\n\ndef parse_qucpl(source_code):\n    tree = parser.parse(source_code)\n    return ASTBuilder().transform(tree)\n\nif name == \"main\":\n    print(\"Enter your QuCPL code (end with a blank line):\")\n    lines = []\n    while True:\n        line = input()\n        if line.strip() == \"\":\n            break\n        lines.append(line)\n    code = \"\\n\".join(lines)\n\n    try:\n        ast = parse_qucpl(code)\n        with open(\"teleportation_ast.json\", \"w\") as f:\n            json.dump(ast, f, indent=2)\n        print(\"AST saved to teleportation_ast.json\")\n    except Exception as e:\n        print(\"Error during parsing:\", e)\n</code></pre> <p>The output is an abstract syntax tree (AST) used by the compiler.</p>"},{"location":"programs/","title":"Writing QuCPL Programs","text":"<p>A valid QuCPL program contains: Qubit declarations, Gate operations, Measurement operations,</p> <p>Example: Bell State</p> <pre><code>qubit q0, q1;\nH q0;\nCX q0, q1;\nmeasure q0 -&gt; c0;\nmeasure q1 -&gt; c1;\n</code></pre> <p>Example: GHZ State</p> <pre><code>qubit q0, q1, q2;\nH q0;\nCX q0, q1;\nCX q0, q2;\nmeasure q0 -&gt; c0;\nmeasure q1 -&gt; c1;\nmeasure q2 -&gt; c2;\n</code></pre> <p>Example: Teleportation</p> <pre><code>qubit q0, q1, q2;\nqop h q1;\nqop cx q1, q2;\nqop cx q0, q1;\nqop h q0;\nmeasure q0, q1 -&gt; c0, c1;\nif (c1 == 1) {\n  qop x q2;\n}\nif (c0 == 1) {\n  qop z q2;\n}\nprint q2;\n</code></pre> <p>bell.qucpl: Generates Bell pair</p> <p>ghz.qucpl: Tripartite GHZ entanglement</p> <p>teleportation.qucpl: Full quantum teleportation</p>"},{"location":"simulation/","title":"Simulation","text":"<p>Simulation.py code :</p> <p>Outputs include final statevector</p> <p>probabilities</p> <p>histogram and counts</p> <p>Uses Qiskit\u2019s AerSimulator</p> <p>Saves and fetches statevector, counts</p> <p>Handles IR-to-circuit building and Qiskit execution</p> <p>From simulation.ipynb:</p> <pre><code>import json\nfrom qiskit import transpile, QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\n\ndef build_qiskit_circuit(ir):\n    qubits = ir[\"qubits\"]\n    instructions = ir[\"instructions\"]\n    classical_bits = sorted(set(\n        c for instr in instructions if instr[\"op\"] == \"measure\"\n        for c in instr.get(\"classical\", [])\n    ))\n\n    qc = QuantumCircuit(len(qubits), len(classical_bits))\n    qmap = {q: i for i, q in enumerate(qubits)}\n    cmap = {c: i for i, c in enumerate(classical_bits)}\n\n    valid_gates = {\"h\", \"x\", \"y\", \"z\", \"cx\", \"cz\", \"ccx\", \"swap\", \"cy\", \"measure\", \"print\"}\n    gate_counts = {}\n\n    for instr in instructions:\n        op = instr[\"op\"]\n\n        if op not in valid_gates:\n            print(f\"[ERROR] Unknown operation '{op}' in instruction: {instr}\")\n            continue\n\n        try:\n            if op in {\"h\", \"x\", \"y\", \"z\"}:\n                if len(instr[\"args\"]) != 1:\n                    raise ValueError(f\"Gate '{op}' expects 1 argument.\")\n                qc.__getattribute__(op)(qmap[instr[\"args\"][0]])\n\n            elif op in {\"cx\", \"cz\", \"swap\", \"cy\"}:\n                if len(instr[\"args\"]) != 2:\n                    raise ValueError(f\"Gate '{op}' expects 2 arguments.\")\n                getattr(qc, op)(qmap[instr[\"args\"][0]], qmap[instr[\"args\"][1]])\n\n            elif op == \"ccx\":\n                if len(instr[\"args\"]) != 3:\n                    raise ValueError(f\"Gate 'ccx' expects 3 arguments.\")\n                qc.ccx(qmap[instr[\"args\"][0]], qmap[instr[\"args\"][1]], qmap[instr[\"args\"][2]])\n\n            elif op == \"measure\":\n                for q, c in zip(instr[\"qubits\"], instr[\"classical\"]):\n                    qc.measure(qmap[q], cmap[c])\n\n            elif op == \"print\":\n                print(f\"[PRINT] {', '.join(instr['args'])}\")\n\n            gate_counts[op] = gate_counts.get(op, 0) + 1\n\n        except KeyError as e:\n            print(f\"[RUNTIME ERROR] Unknown qubit/classical bit '{e}' in: {instr}\")\n        except ValueError as e:\n            print(f\"[ARGUMENT ERROR] {e} Instruction: {instr}\")\n        except Exception as e:\n            print(f\"[UNEXPECTED ERROR] {e} in instruction: {instr}\")\n\n    print(\"\\n[GATE COUNTS]\")\n    for gate, count in gate_counts.items():\n        print(f\"{gate}: {count}\")\n\n    return qc, classical_bits\n\ndef simulate(ir_path, title):\n    try:\n        with open(ir_path) as f:\n            ir = json.load(f)\n    except FileNotFoundError:\n        print(f\"[FILE ERROR] IR file '{ir_path}' not found.\")\n        return\n\n    qc, classical_bits = build_qiskit_circuit(ir)\n    sim = Aer.get_backend('aer_simulator')\n\n    try:\n        job = sim.run(transpile(qc, sim), shots=1024)\n        result = job.result()\n        counts = result.get_counts()\n    except Exception as e:\n        print(f\"[SIMULATION ERROR] {e}\")\n        return\n\n    print(f\"\\n--- {title} Simulation Results ---\")\n    print(\"Counts:\", counts)\n    print(\"Backend:\", sim.name)\n    print(\"Total time taken:\", result.time_taken, \"seconds\")\n    plot_histogram(counts, title=title)\n    plt.show()\n\nif __name__ == \"__main__\":\n    simulate(\"teleportation_ir.json\", \"Quantum Teleportation\")\n</code></pre>"},{"location":"visualize/","title":"Visualization","text":"<p>Uses Qiskit to draw circuits:</p> <p>Circuit drawing via circuit_drawer(qc)</p> <p>Measurement histogram via plot_histogram()</p> <p>State visualization via plot_bloch_multivector()</p> <p>From visualize.ipynb:</p> <pre><code>import json\nimport matplotlib.pyplot as plt\nfrom qiskit import QuantumCircuit\n\ndef visualize_circuit(ir, title):\n    qubits = ir[\"qubits\"]\n    instructions = ir[\"instructions\"]\n\n    num_qubits = len(qubits)\n    classical_bits = sorted(set(c for instr in instructions if instr[\"op\"] == \"measure\" for c in instr.get(\"classical\", [])))\n\n    qc = QuantumCircuit(num_qubits, len(classical_bits))\n    qmap = {q: i for i, q in enumerate(qubits)}\n    cmap = {c: i for i, c in enumerate(classical_bits)}\n\n    for instr in instructions:\n        op = instr[\"op\"]\n        try:\n            args = instr.get(\"args\", [])\n            if op == \"h\":\n                qc.h(qmap[args[0]])\n            elif op == \"x\":\n                qc.x(qmap[args[0]])\n            elif op == \"y\":\n                qc.y(qmap[args[0]])\n            elif op == \"z\":\n                qc.z(qmap[args[0]])\n            elif op == \"cx\":\n                qc.cx(qmap[args[0]], qmap[args[1]])\n            elif op == \"cy\":\n                qc.cy(qmap[args[0]], qmap[args[1]])\n            elif op == \"cz\":\n                qc.cz(qmap[args[0]], qmap[args[1]])\n            elif op == \"ccx\":\n                qc.ccx(qmap[args[0]], qmap[args[1]], qmap[args[2]])\n            elif op == \"swap\":\n                qc.swap(qmap[args[0]], qmap[args[1]])\n            elif op == \"measure\":\n                for q, c in zip(instr[\"qubits\"], instr[\"classical\"]):\n                    qc.measure(qmap[q], cmap[c])\n            elif op == \"print\":\n                print(\"PRINT:\", \", \".join(args))\n            else:\n                print(f\"Unknown op '{op}' in instruction: {instr}\")\n        except Exception as e:\n            print(f\"Error processing {op}: {e} in {instr}\")\n\n    fig = qc.draw(\"mpl\")\n    fig.suptitle(title)\n    plt.show()\n\nif __name__ == \"__main__\":\n    with open(\"teleportation_ir.json\") as f:\n        teleport_ir = json.load(f)\n\n    visualize_circuit(teleport_ir, \"Quantum Teleportation\")\n</code></pre> <p>Also supports Bloch spheres and histogram plotting.</p>"}]}