{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to QUCPL Documentation","text":"<p>This site documents the Quantum Computing Programming Language (QUCPL) project, developed by Mellimpudi Tejas during a Practice School-I internship at Quinfo Systems Pvt. Ltd, Hyderabad, under the guidance of BITS Pilani.</p>"},{"location":"#about-me","title":"About Me","text":"<p>Name: Mellimpudi Tejas</p> <p>ID: 2023B5A70802H</p> <p>Discipline: MSc Physics, BE CSE (Dual)</p> <p>Institution: BITS Pilani, Hyderabad Campus</p> <p>Email: f20230802@hyderabad.bits-pilani.ac.in</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>QUCPL is a custom domain-specific language designed to simplify quantum programming. This documentation covers its development, from quantum foundations to implementation, including code, theory, and visualizations from my internship report (July 2025). Explore the sections below to learn more about quantum computing, QUCPL\u2019s design, and its capabilities.</p>"},{"location":"ast_output/","title":"Abstract Syntax Tree (AST) Output","text":"<p>The Abstract Syntax Tree (AST) is a hierarchical representation of the QUCPL program's structure, generated by parsing the source code using the Lark parser in Python. This section details the AST generation process and provides a sample AST output for the Bell state program, as implemented during Week 3 of the internship.</p>"},{"location":"ast_output/#ast-generation-process","title":"AST Generation Process","text":"<p>The AST is created using the following steps:</p> <p>Source Code Parsing: The QUCPL source code is parsed using a grammar defined in grammar.lark with the Lark parsing library.</p> <p>Tree Transformation: A Transformer class processes the parse tree to produce a simplified AST, which is structured for further compilation into an Intermediate Representation (IR).</p> <p>JSON Serialization: The AST is saved as a JSON file (ast.json) for compatibility with downstream tools like the compiler and simulator.</p>"},{"location":"ast_output/#example-program-bell-state-in-qucpl","title":"Example Program: Bell State in QuCPL","text":"<p>Declares two qubits (q0, q1) initialized in the ( |0\\rangle ) state.</p> <p>Applies a Hadamard gate (h) to q0, creating a superposition.</p> <p>Applies a CNOT gate (cx) with q0 as control and q1 as target, entangling the qubits.</p> <p>Measures both qubits into classical bits c0 and c1.</p> <p>Expected Output:</p> <p>\u2022 Since the qubits are in a Bell state, the result will always be correlated.</p> <p>\u2022 Either 00 or 11, each with 50% probability.</p> <p>Sample AST Output (ast.json): The successful parsing and AST generation validates the correctness of both the language design and the parser implementation.</p> <p></p>"},{"location":"ast_output/#explanation-of-ast-structure","title":"Explanation of AST Structure","text":"<p>type: \"program\": The root node, encapsulating the entire program.</p> <p>body: A list of statements, each representing a QUCPL construct:</p> <p>qubit_decl: Declares qubits (q0, q1).</p> <p>gate: Specifies gate operations (h, cx) with their arguments.</p> <p>measure: Maps qubit measurements to classical bits.</p> <p>This AST validates the correctness of the parser and serves as input for the IR generation phase.</p>"},{"location":"compiler/","title":"Compiler","text":"<p>The compiler is a crucial component of the QUCPL (Quantum Computing Programming Language) project. It transforms the high-level quantum programs written in QuCPL into a structured, low-level format that can be executed on quantum hardware or simulators. Specifically, the compiler takes the Abstract Syntax Tree (AST) generated by the parser and converts it into an Intermediate Representation (IR), which is a JSON-based format designed to be backend-agnostic and easy to process.</p>"},{"location":"compiler/#introduction-to-the-compiler","title":"Introduction to the Compiler","text":"<p>The compiler serves as the bridge between the user-friendly syntax of QuCPL and the operational instructions needed for quantum computation. Its primary responsibilities include:</p> <p>Traversing the AST to identify and process different types of statements (e.g., gate operations, measurements, conditionals).</p> <p>Converting each statement into a corresponding instruction in the IR.</p> <p>Managing declarations of qubits and classical bits.</p> <p>Handling control flow constructs such as if statements.</p> <p>Performing basic validation to ensure the program\u2019s semantic correctness.</p> <p>By generating a standardized IR, the compiler enables QuCPL programs to be translated into various backend formats, such as Qiskit circuits, for simulation or execution.</p>"},{"location":"compiler/#compiler-implementation","title":"Compiler Implementation","text":"<p>The compiler is implemented in the compiler.py script, which contains several key functions to transform the AST into IR. Main Functions</p> <p>ast_to_ir(ast): Initializes the IR structure with empty lists for qubits, classical bits, instructions, and control flow. Processes each statement in the AST: Adds qubit and classical bit declarations to the respective lists. Uses compile_stmt to convert other statements into IR instructions.</p> <p>compile_stmt(stmt): Handles individual statements by matching their type (e.g., gate, measure, if, print). Returns the corresponding IR instruction object.</p> <p>flatten(args): A utility function that ensures arguments (e.g., qubit lists) are flattened into a single array, as required by the IR schema.</p> <p></p>"},{"location":"compiler/#compilation-process","title":"Compilation Process","text":"<p>Initialization: Create an empty IR structure.</p> <p>Declaration Handling: Add declared qubits and classical bits to the IR.</p> <p>Statement Compilation: For each statement in the AST.</p> <p>Use compile_stmt to generate the appropriate IR instruction.</p> <p>Append the instruction to the \"instructions\" list.</p> <p>Control Flow: If control flow statements are present, compile them into the \"control_flow\" field.</p> <p>This structured approach ensures that the entire program is accurately represented in the IR.</p>"},{"location":"compiler/#handling-different-statement-types","title":"Handling Different Statement Types","text":"<p>The compiler supports various statement types, each requiring specific handling:</p>"},{"location":"compiler/#gate-operations","title":"Gate Operations","text":"<p>Example: h q0; or cx q0, q1;</p> <p>Compilation:</p> <p>Extract the gate name and qubit arguments.</p> <p>Flatten the arguments using flatten.</p> <p>Create an instruction: {\"type\": \"gate\", \"name\": \"h\", \"args\": [\"q0\"]}</p>"},{"location":"compiler/#measurements","title":"Measurements","text":"<p>Example: measure q0 -&gt; c0;</p> <p>Compilation:</p> <p>Identify the qubit to measure and the target classical bit.</p> <p>Create an instruction: {\"type\": \"measure\", \"qubit\": \"q0\", \"target\": \"c0\"}</p>"},{"location":"compiler/#conditional-statements","title":"Conditional Statements","text":"<p>Example: if (c0 == 1) { x q2; }</p> <p>Compilation:</p> <p>Process the condition and the nested block.</p> <p>Recursively compile the inner statements.</p> <p>Nest the compiled instructions within a control flow block in the IR.</p>"},{"location":"compiler/#print-statements","title":"Print Statements","text":"<p>Example: print c0;</p> <p>Compilation:</p> <p>Identify the variables or literals to print.</p> <p>Create an instruction: {\"type\": \"print\", \"args\": [\"c0\"]}</p> <p>Each statement type is handled by a specific case in the compile_stmt function, ensuring accurate translation to IR.</p> <p>The resulting IR is a JSON object ready for simulation or execution.</p>"},{"location":"compiler/#error-handling-and-validation","title":"Error Handling and Validation","text":"<p>The compiler includes basic error handling and validation to ensure program correctness:</p> <p>Undeclared Variables: Raises an error if a qubit or classical bit is used without declaration.</p> <p>Invalid Gate Arguments: Detects and reports if a gate is applied with the wrong number of arguments (e.g., cx q0; instead of cx q0, q1;).</p> <p>Type Mismatches: Ensures measurements are performed on qubits and stored in classical bits.</p> <p>These checks help catch common mistakes early, improving the reliability of QuCPL programs.</p>"},{"location":"conclusions/","title":"Conclusions and Recommendations","text":""},{"location":"conclusions/#summary-of-work-done","title":"Summary of Work Done","text":"<p>These 7 weeks of this internship provided a strong and structured foundation for exploring the design and implementation of a domain-specific quantum programming language(QuCPL). The journey began with a deep dive into quantum foundations, focusing on core principles such as qubits, superposition, entanglement, and quantum gates. These theoretical insights were reinforced through practical implementation using Qiskit, IBM's open-source framework for quantum computing.</p> <p>In Week 1, I successfully studied and understood the main concepts of quantum information and computing and got hands on practice of circuits using qiskit and ibm tutorials . Alongside, I prepared a short technical report titled \u201cWhat is a Qubit?\u201d, which helped consolidate my conceptual understanding and served as a useful documentation piece for future reference.</p> <p>In week 2, I have created a Bell state quantum circuit, one of the simplest and most fundamental examples of entanglement in quantum computing. Then practiced and made circuits for quantum superposition, entanglement, teleportation, etc.</p> <p>In Week 3 shifted the focus toward language design and compiler fundamentals, where I formally defined the syntax for QuCPL using a PEG-based grammar written for the Lark parser in Python. A working parser was implemented that reads quantum source code and produces a well-structured Abstract Syntax Tree (AST).</p> <p>In Week 4, I designed a JSON-based Intermediate Representation (IR) and built a compiler to translate ASTs into IR. I also implemented basic circuit visualizations from the IR, helping bridge the gap between abstract code and tangible quantum circuits.</p> <p>Week 5 involved backend integration with Qiskit. I translated IR to Qiskit code, simulated Bell and GHZ circuits, and generated outputs such as histograms, statevectors, and logs, confirming correctness and performance.</p> <p>In Week 6, I implemented a quantum teleportation protocol using QuCPL and added runtime validation and error handling. These features ensured more robust and fault-tolerant execution.</p> <p>Finally, in Week 7, I documented the project thoroughly, created demo videos, launched the GitHub repository, and set up a professional documentation site using MkDocs. This made the tool accessible for future development and open-source contributions.</p> <p>Overall, this internship deepened my understanding of quantum computing while giving me practical skills in language design, compiler construction, and software engineering.</p>"},{"location":"conclusions/#challenges-and-learnings","title":"Challenges and Learnings","text":"<p>Over the course of the 7-week internship, the project evolved from theoretical exploration to building a functional quantum programming pipeline. While the outcomes were productive and meaningful, the journey came with several technical and conceptual challenges\u2014each of which led to valuable insights and deeper learning.</p> <ol> <li> <p>Conceptual Complexity in Quantum Computing: Quantum mechanics is inherently abstract and counterintuitive. Concepts like superposition, entanglement, and statevector evolution required in-depth study and experimentation. I often had to consult multiple resources and run practical simulations using Qiskit to fully grasp the mathematical and physical underpinnings. Implementing teleportation and GHZ circuits helped reinforce these ideas through hands-on application.</p> </li> <li> <p>Language Syntax Design Trade-offs: Designing a custom syntax for the QuCPL language involved trade-offs between clarity, conciseness, and parsing feasibility. I reviewed syntactic patterns from existing DSLs like Qiskit, OpenQASM, and Silq to identify common best practices. Crafting a syntax that is both beginner-friendly and powerful required several iterations and constant testing to strike the right balance.</p> </li> <li> <p>Grammar Debugging with Lark: Writing a reliable PEG-based grammar using the Lark parser was one of the more technical challenges. It required not just implementing the formal syntax but ensuring the parser could handle invalid inputs gracefully, support multi-qubit operations, and correctly map conditional constructs. Many bugs were uncovered only through exhaustive test-driven refinement, which improved my debugging skills significantly.</p> </li> <li> <p>AST Design and Structuring: Creating an extensible and semantically clear AST (Abstract Syntax Tree) structure was another key challenge. I had to consider naming conventions, node hierarchy, and how each construct could later be translated into IR or simulated by the backend. Ensuring the AST supported advanced features like measurement, branching, and loops without becoming overly complex taught me the importance of modular and forward-compatible design.</p> </li> <li> <p>IR Translation and Backend Integration: Designing a JSON-based Intermediate Representation (IR) that could bridge the AST and Qiskit backend required careful planning. Each IR instruction had to be expressive enough for simulation while remaining easy to serialize and debug. Converting this IR into executable Qiskit code helped me understand how low-level gate operations and circuit metadata are handled in real-world quantum systems.</p> </li> <li> <p>Visualization and Simulation Constraints: Building visualizations from the IR and simulating circuits like Bell, GHZ, and teleportation with histograms and statevectors revealed the practical constraints of quantum simulation (e.g., state size, noise models, backend limitations). Debugging the visualization output and aligning it with Qiskit\u2019s internal states improved both my understanding and tool-building skills.</p> </li> <li> <p>Documentation and Usability Considerations: In the final week, preparing clean documentation, writing a README.md, creating tutorials, and building a MkDocs site highlighted the importance of clear communication in open-source tools. Making the project accessible to new users through guides and demos required me to revisit early design decisions from a user-experience perspective.</p> </li> </ol> <p>Despite these challenges, each phase of the internship contributed to a solid foundation in quantum programming, language and compiler design, and practical software engineering. I\u2019ve come away with a deeper understanding of how complex systems are built from the ground up\u2014balancing theory with implementation, and structure with usability.</p>"},{"location":"conclusions/#recommendations-for-future-work","title":"Recommendations for Future Work","text":"<p>Over the course of this 7-week internship, I was able to lay the foundation for QuCPL, a domain-specific quantum programming language that supports syntax parsing, IR generation, backend simulation, and visualization. While the progress has been significant, there is considerable scope for extending the language, improving tooling, and enhancing its practical usability. Based on the current state of development and the challenges encountered, I propose the following directions for future work:</p> <ol> <li> <p>Build a Full-Featured Circuit Visualizer: The initial visualization tool developed in Week 4 can be expanded into a graphical circuit editor or viewer that directly renders circuits from the IR or AST. Enhancing this with drag-and-drop interfaces or interactive simulations could make QuCPL a valuable tool for both education and research.</p> </li> <li> <p>Implement Semantic Checking and Static Analysis: Currently, syntax-level validation is handled during parsing. In future versions, a dedicated semantic analysis module should be added to catch issues such as undeclared qubits, repeated measurements, or type mismatches. Clear and context-aware error messages will greatly enhance the debugging and learning experience.</p> </li> <li> <p>Support for Complex Quantum Protocols: In Weeks 5 and 6, I implemented Bell, GHZ, and teleportation programs using QuCPL. Future work should include support for additional quantum protocols like Quantum Key Distribution (QKD), superdense coding, or Grover\u2019s algorithm. Including built-in libraries or templates for these protocols would accelerate development and adoption.</p> </li> <li> <p>Integration with Real Quantum Hardware: Currently, the backend supports simulation using Qiskit\u2019s local simulator. Future development should focus on running compiled QuCPL programs on actual quantum hardware using Qiskit Runtime or cloud-based quantum services. This would offer real-world feedback on circuit performance and fidelity.</p> </li> <li> <p>Improve Packaging, GUI, and Developer Tools: The current toolchain could be expanded into a more polished IDE or GUI application, integrating simulation output, visualization, syntax highlighting, and export features. Building a standalone executable, adding support for OpenQASM import/export, and embedding tutorials directly in the interface would improve usability significantly.</p> </li> <li> <p>Documentation, Tutorials, and Community Engagement: In Week 7, I developed a full documentation site using MkDocs and recorded tutorial videos to help onboard new users. For long-term sustainability, it\u2019s important to maintain versioned documentation, provide example programs, and open the project to community contributions. A GitHub Discussions forum or Discord server could also help build a user base around QuCPL.</p> </li> </ol>"},{"location":"conclusions/#reflections-and-takeaways","title":"Reflections and Takeaways","text":"<p>This 7-week internship has been one of the most intellectually rewarding and transformative experiences of my academic journey. It offered a unique opportunity to work at the intersection of quantum physics and computer science, blending theory with hands-on systems development. Building QuCPL\u2014a quantum programming language from the ground up\u2014allowed me to engage deeply with both abstract scientific ideas and the rigor of software engineering.</p> <p>From the technical perspective, I gained end-to-end exposure to compiler design, quantum simulation, and toolchain integration:</p> <p>\u2022 I learned how to write formal grammars using PEG and implement a working parser with Lark in Python.</p> <p>\u2022 I designed a clean and extensible Abstract Syntax Tree (AST) format and translated it into a backend-agnostic Intermediate Representation (IR).</p> <p>\u2022 I integrated this IR with Qiskit, allowing execution of programs written in QuCPL on simulators with full support for Bell, GHZ, and teleportation protocols.</p> <p>\u2022 I also developed circuit visualization tools, runtime error handling, and a structured MkDocs-based documentation site, all of which helped polish the usability and functionality of the platform.</p> <p>From a personal and professional standpoint, the internship helped me grow in multiple dimensions:</p> <p>\u2022 I significantly improved my problem-solving and debugging skills, especially while building the grammar, managing parser errors, and designing the IR.</p> <p>\u2022 The freedom to experiment and build from scratch taught me the importance of modularity, clarity, and future-proof design in software development.</p> <p>\u2022 My ability to self-learn complex concepts, manage project timelines, and communicate technical ideas clearly\u2014in both written documentation and recorded tutorials\u2014improved.</p> <p>Overall, this internship has laid a strong technical and conceptual foundation. It has motivated me to continue evolving QuCPL into a complete, professional-grade tool, and to explore more advanced topics such as optimization, real-device execution, and formal verification. I am incredibly grateful for the opportunity, and I look forward to building on this work in future research, academic, or open-source settings.</p>"},{"location":"entanglement_tele/","title":"ENTANGLEMENT AND QUANTUM INFORMATION","text":""},{"location":"entanglement_tele/#entanglement","title":"ENTANGLEMENT","text":"<p>\u2022 Quantum entanglement is a physical phenomenon where two or more qubits become linked in such a way that the state of one instantly influences the state of the other \u2014no matter the distance between them.</p> <p>\u2022 If qubits A and B are entangled, measuring A collapses the state of B\u2014even if B is far away.</p> <p>\u2022 Qubits are perfectly correlated</p> <p>\u2022 An entangled state cannot be written as: \u2223\u03c8\u27e9=\u2223\u03c81\u27e9\u2297\u2223\u03c82\u27e9</p> <p>\u2022 Instead, it's a non-separable superposition of multiple states: \u2223\u03c8\u27e9=\u03b1\u222300\u27e9+\u03b2\u222311\u27e9</p> <p>\u2022 Used in Quantum teleportation, QKD, superdense coding.</p> <p>\u2022 Example: Bell State </p> <p>Properties of Bell States</p> <p>\u2022 Maximal Entanglement: Measurement of one qubit immediately determines the state of the other, regardless of distance.</p> <p>\u2022 Orthogonality: All Bell states are mutually orthogonal: \u27e8\u03a6+\u2223\u03a6\u2212\u27e9=0,\u27e8\u03a8+\u2223\u03a8\u2212\u27e9=0</p> <p>\u2022 Completeness: They form a complete basis for two-qubit states, meaning any two-qubit state can be expressed as a combination of Bell states.</p> <p>Applications of Bell States</p> <p>\u2022 Quantum Teleportation: Used as the entangled resource shared between Alice and Bob.</p> <p>\u2022 Superdense Coding: Sends 2 classical bits using 1 qubit.</p> <p>\u2022 Entanglement-based Quantum Key Distribution: Ensures secure communication using Bell inequality violations.</p> <p>\u2022 How to Create Entanglement between two qubits:</p> <p>1.Apply a Hadamard gate to qubit 0 to create superposition.</p> <p>2.Apply a CNOT gate from qubit 0 (control) to qubit 1 (target).</p> <p>\u2022 Below is the code for entanglement, output circuit and the results :</p> <p></p>"},{"location":"entanglement_tele/#quantum-teleportation","title":"QUANTUM TELEPORTATION","text":"<p>Quantum teleportation is a protocol that enables the transfer of a quantum state from one qubit (held by Alice, the sender) to another distant qubit (held by Bob, the receiver), using a combination of quantum entanglement and classical communication. Notably, the qubit itself is not physically transmitted; instead, its exact state is recreated on Bob\u2019s qubit.</p> <p>1.Initial Setup</p> <p>\u2022 Alice possesses a qubit in an unknown quantum state, denoted as:   \u2223\u03c8\u27e9=\u03b1\u22230\u27e9+\u03b2\u22231\u27e9</p> <p>\u2022 Alice and Bob share an entangled pair of qubits, labelled Qubit 1 and Qubit 2, prepared in the Bell state: \u2223\u03a6+\u27e9=12(\u222300\u27e9+\u222311\u27e9)</p> <p>\u2022 Qubit 0: Alice's message qubit</p> <p>\u2022 Qubit 1: Alice's part of the entangled pair</p> <p>\u2022 Qubit 2: Bob's part of the entangled pair</p> <p>\u2022 Alice can send 2 classical bits(from her measurement) to Bob through a classical channel.</p> <p>2.Entangle &amp; Measure (Alice's Operations)</p> <p>\u2022 Apply a CNOT gate with Qubit 0 (control) and Qubit 1 (target).</p> <p>\u2022 Apply a Hadamard gate to Qubit 0.</p> <p>\u2022 Measure Qubits 0 and 1 in the computational basis.</p> <p>\u2022 Send the 2-bit measurement result to Bob via classical communication.</p> <p>3.Bob's Correction (Based on Alice's Measurement)</p> <p>\u2022  Upon receiving Alice\u2019s two classical bits, Bob applies a conditional quantum gate to Qubit 2:</p> <p>Alice\u2019s Measurement  Bob\u2019s Operation 00                     None 01                   X (bit-flip) 10                   Z (phase-flip) 11                   Z followed by X</p> <p>\u2022 After the correction, Bob\u2019s qubit (Qubit 2) exactly reproduces the original quantum state \u2223\u03c8\u27e9.</p> <p>Key Observations:</p> <p>\u2022 The quantum state is destroyed on Alice's side after measurement \u2014 she no longer holds \u2223\u03c8\u27e9|.</p> <p>\u2022 This is consistent with the no-cloning theorem: a quantum state cannot be copied, only transferred.</p> <p>\u2022 Teleportation thus requires: A shared entangled pair, Classical communication of 2 bits, Local quantum operations by Bob.</p> <p>\u2022 Code snippet and the measured results are shown below :</p> <p></p>"},{"location":"glossary/","title":"Glossary","text":"<p>This glossary compiles key terms and concepts encountered and applied throughout the 7-week development of QuCPL, a domain-specific language for quantum computing. It includes definitions from quantum mechanics, language design, compiler theory, and software development, providing context for both the theoretical foundations and the practical tools used.</p>"},{"location":"glossary/#quantum-computing-terms","title":"Quantum Computing Terms","text":"<p>\u2022 Qubit: The fundamental unit of quantum information. Unlike a classical bit, a qubit can exist in a superposition of 0 and 1, enabling parallel computation.</p> <p>\u2022 Superposition: A quantum property that allows qubits to exist in multiple states simultaneously until measured. Practiced using the Hadamard gate in Week 1.</p> <p>\u2022 Entanglement: A phenomenon where two or more qubits become linked, such that measuring one affects the state of the other. Implemented in Bell and GHZ circuits (Weeks 2\u20133).</p> <p>\u2022 Quantum Gate: A unitary operation that changes the state of one or more qubits. Gates like Hadamard (H), CNOT, and X were used across all quantum programs.</p> <p>\u2022 Hadamard Gate (H): A single-qubit gate that places a qubit into an equal superposition of |0\u27e9 and |1\u27e9.</p> <p>\u2022 CNOT Gate: A two-qubit gate that flips the target qubit if the control qubit is |1\u27e9. Key to creating entanglement.</p> <p>\u2022 Measurement: The act of observing a qubit, collapsing it to a classical state (0 or 1). Used in all simulations and circuit terminations.</p> <p>\u2022 Bell State: A maximally entangled two-qubit state, generated in Week 2 to test QuCPL\u2019s basic gate functionality.</p> <p>\u2022 Quantum Circuit: A structured sequence of quantum gates applied to qubits. Represented textually in QuCPL and visually using IR-based tools (Weeks 4\u20135).</p>"},{"location":"glossary/#quantum-software-and-tools","title":"Quantum Software and Tools","text":"<p>\u2022 Qiskit: IBM\u2019s open-source quantum computing framework used to simulate and execute QuCPL-generated circuits. Integrated in Weeks 1, 2, 5, and 6.</p> <p>\u2022 Aer Simulator: Qiskit\u2019s high-performance simulator backend used to test circuits virtually before running them on real hardware.</p> <p>\u2022 QuEDX: An interactive quantum learning platform used during Weeks 1 and 2 for visualizing gate operations and enhancing conceptual understanding.</p>"},{"location":"glossary/#language-design-and-compiler-terms","title":"Language Design and Compiler Terms","text":"<p>\u2022 Domain-Specific Language (DSL): A programming language tailored for a specific domain. QuCPL was designed as a DSL for quantum circuit expression and simulation.</p> <p>\u2022 Grammar: A formal set of syntax rules defining valid program structure. Written in PEG using the Lark parser during Weeks 2\u20133.</p> <p>\u2022 Parsing: The process of analyzing and converting source code into a structured format. Implemented using Lark in Week 3.</p> <p>\u2022 Lark Parser: A Python parsing library supporting both LALR and Earley algorithms. Used to build QuCPL\u2019s grammar and AST transformation pipeline.</p> <p>\u2022 Abstract Syntax Tree (AST): A tree-based data structure representing the hierarchical syntax of a program. Generated in JSON during Week 3.</p> <p>\u2022 Intermediate Representation (IR): A backend-neutral JSON format capturing the logic of a quantum program. Designed in Week 4 for simulation and visualization.</p> <p>\u2022 Transformer: A component that walks through the parse tree and outputs a cleaner AST. Used extensively in the parser module of QuCPL.</p> <p>\u2022 JSON (JavaScript Object Notation): A lightweight data format used to serialize ASTs and IRs for backend integration and visualization across Weeks 3\u20135.</p>"},{"location":"glossary/#general-computing-and-project-terms","title":"General Computing and Project Terms","text":"<p>\u2022 Simulator: A software tool that emulates a quantum processor, allowing programs to be tested without quantum hardware. Qiskit\u2019s Aer was used throughout the internship.</p> <p>\u2022 Backend: The layer responsible for circuit execution. In Qiskit, it refers to the simulation engine or quantum hardware. The IR-to-Qiskit backend integration was completed in Week 5.</p> <p>\u2022 Comment: Non-executable text in code used for annotations. In QuCPL, comments begin with // and were added to improve readability and documentation.</p> <p>\u2022 Control Flow: Constructs that affect the sequence of execution (e.g., if, loop, while). Basic IF and MEASURE support was implemented in Week 3, with future expansion planned.</p>"},{"location":"grammar/","title":"Grammar Specification using Lark (PEG)","text":"<p>The QUCPL grammar was defined using Lark's PEG syntax in a file named grammar.lark.</p> <p>This grammar specifies the rules for valid QUCPL programs, including qubit declarations, gate operations, measurements, and comments.</p> <p></p>"},{"location":"grammar/#key-features","title":"Key Features","text":"<p>Qubit Declarations: Syntax like qubit q0, q1; declares one or more qubits.</p> <p>Gate Operations: Supports single-qubit gates (h, x, y, z, rx, ry, rz) and multi-qubit gates (cx), e.g., h q0; or cx q0, q1;.</p> <p>Measurement: Syntax like measure q0 -&gt; c0; measures a qubit and stores the result in a classical bit.</p> <p>Comments: Lines starting with // are ignored, enhancing code readability.</p> <p>Extensibility: The grammar is designed to support future additions like control flow (if, loop) and custom gates.</p>"},{"location":"grammar/#the-grammar-uses-larks-conventions","title":"The grammar uses Lark\u2019s conventions","text":"<p>WS ignores whitespace for cleaner parsing.</p> <p>Comments are ignored during parsing but preserved for documentation.</p> <p>IDENTIFIER supports alphanumeric names for qubits and classical bits.</p>"},{"location":"introduction/","title":"Introduction to QUCPL","text":"<p>Welcome to the documentation for QUCPL (Quantum Computing Programming Language), a domain-specific language designed to simplify the process of writing and understanding quantum programs. Developed during a Practice School-I internship at Quinfo Systems Pvt. Ltd, Hyderabad, under the guidance of BITS Pilani, QUCPL aims to bridge the gap between the complex world of quantum mechanics and the practical needs of programmers.</p>"},{"location":"introduction/#objectives-of-the-internship","title":"Objectives of the Internship","text":"<p>The primary objective of this internship was to develop both a theoretical and practical understanding of quantum computing and apply this knowledge to the design and implementation of a custom quantum programming language named QuCPL (Quantum Computing Programming Language). The broader aim was to bridge quantum theory with programming language principles, ultimately creating a functional toolchain capable of parsing high-level quantum programs, generating structured intermediate representations, and simulating quantum behavior.</p> <p>The key outcomes envisioned for the internship were:</p> <p>Designing a clean and readable quantum programming syntax.</p> <p>Implementing a grammar and parser using Python.</p> <p>Translating code into a structured JSON-based Intermediate Representation (IR).</p> <p>Simulating quantum circuits from the IR using custom tools.</p> <p>Visualizing circuits and results.</p> <p>Documenting and releasing the project for public use.</p>"},{"location":"introduction/#what-is-qucpl","title":"What is QUCPL?","text":"<p>QUCPL is a custom programming language tailored for quantum computing. It provides a high-level, human-readable syntax that abstracts away the intricacies of quantum hardware and low-level quantum operations. By doing so, QUCPL makes it easier for developers, researchers, and students to experiment with quantum algorithms and protocols without getting bogged down by the underlying complexities.</p> <p>The language is designed to be:</p> <p>Intuitive: With a syntax that is easy to read and write, even for those new to quantum computing.</p> <p>Expressive: Capable of representing a wide range of quantum operations and protocols.</p> <p>Educational: Serving as a tool to learn and teach quantum computing concepts.</p>"},{"location":"introduction/#why-qucpl","title":"Why QUCPL?","text":""},{"location":"introduction/#quantum-computing-is-a-rapidly-evolving-field-with-the-potential-to-revolutionize-various-industries-however-programming-quantum-computers-remains-a-challenge-due-to","title":"Quantum computing is a rapidly evolving field with the potential to revolutionize various industries. However, programming quantum computers remains a challenge due to","text":"<p>The counterintuitive nature of quantum mechanics.</p> <p>The need for specialized knowledge to design quantum circuits.</p> <p>The lack of accessible tools for quantum programming.</p>"},{"location":"introduction/#qucpl-addresses-these-challenges-by-providing-a-language-that","title":"QUCPL addresses these challenges by providing a language that","text":"<p>Abstracts quantum operations into familiar programming constructs.</p> <p>Allows for the expression of quantum algorithms in a clear and concise manner.</p> <p>Integrates with existing quantum frameworks like Qiskit for simulation and execution.</p>"},{"location":"introduction/#structure-of-the-documentation","title":"Structure of the Documentation","text":""},{"location":"introduction/#this-documentation-is-structured-to-guide-you-through-the-journey-of-understanding-and-using-qucpl","title":"This documentation is structured to guide you through the journey of understanding and using QUCPL","text":"<p>Quantum Foundations: A primer on the essential quantum computing concepts needed to understand QUCPL.</p> <p>Language Design: An in-depth look at the syntax, grammar, and design principles of QUCPL.</p> <p>Grammar:</p> <p>Parser:Details on how QUCPL code is parsed and produces Abstract Syntax Tree (AST).</p> <p>Compiler:Details on how AST generated by parser is compiled and produces Intermediate Representation (IR).</p> <p>Visualization: It provides a way to visualize the quantum circuits and results generated by QUCPL.</p> <p>Simulation: It provides a way to simulate the quantum circuits and show results generated by histograms and runtime logs.</p> <p>Teleportation Protocol: A practical example of using QUCPL to implement the quantum teleportation protocol.</p> <p>Conclusions: A summary of the project\u2019s achievements and future directions.</p>"},{"location":"introduction/#background-of-quantum-computing-and-programming-languages","title":"Background of Quantum Computing and Programming Languages","text":"<p>Quantum computing represents a paradigm shift from classical computing by leveraging the principles of quantum mechanics. The quantum bit, or qubit, unlike a classical bit, can exist in a superposition of states, allowing quantum computers to perform certain computations exponentially faster. However, programming quantum computers is still in its early stages, with most existing platforms relying on either circuit-level representations or complex APIs.</p> <p>At the heart of quantum computing lie several foundational principles derived from quantum mechanics. The first is superposition, the ability of a qubit to exist simultaneously in multiple states. Unlike a classical bit that is either 0 or 1, a qubit can be in a state \u03b1|0\u27e9 + \u03b2|1\u27e9, where \u03b1 and \u03b2 are complex amplitudes, and the probability of measuring either 0 or 1 is determined by their magnitudes squared. Another key principle is entanglement, a phenomenon where qubits become correlated in such a way that the state of one qubit directly affects the state of another, no matter the physical distance between them. Additionally, quantum interference allows quantum algorithms to amplify the probability of correct outcomes while diminishing incorrect ones, refining computation results in ways classical algorithms cannot.</p> <p>To make quantum programming more accessible and expressive, there is a growing need for domain-specific languages (DSLs) that abstract away hardware-level complexities while preserving the quantum nature of computation. Designing such a language requires a deep understanding of both quantum mechanics and compiler theory. The language must support unique constructs like quantum gates, measurement operations, and potentially quantum control flow, while being translatable into backends like Qiskit for simulation or execution on real hardware.</p>"},{"location":"introduction/#educational-value","title":"Educational Value","text":"<p>Beyond being a programming tool, QUCPL is a learning platform. The documentation not only explains how to use the language but also delves into the quantum computing principles that underpin it. Whether you\u2019re a student, a researcher, or a curious enthusiast, this site offers a hands-on approach to mastering quantum programming.</p>"},{"location":"introduction/#get-started","title":"Get Started","text":"<p>We invite you to explore the documentation, experiment with the code examples, and even contribute to the project. Your feedback is invaluable as we continue to refine and expand QUCPL. Happy quantum coding!</p>"},{"location":"ir_output/","title":"Intermediate Representation (IR) Output","text":"<p>The Intermediate Representation (IR) is a backend-agnostic, JSON-based format that captures the logic of a QUCPL program after parsing and compilation. This section outlines the IR design and provides a sample IR output for the Bell state program, as implemented during Week 4 of the internship.</p>"},{"location":"ir_output/#ir-design-principles","title":"IR Design Principles","text":"<p>The IR was designed to be:</p> <p>Readable: JSON format for easy inspection and debugging.</p> <p>Structured: Separates quantum instructions, qubit declarations, and control flow.</p> <p>Extensible: Supports future constructs like loops and conditionals.</p> <p>Backend-Agnostic: Compatible with Qiskit, OpenQASM, or custom simulators.</p> <p>For IR schema you can see detailed in ir_schema.</p>"},{"location":"ir_output/#ir-generation-process","title":"IR Generation Process","text":"<p>The IR is generated using compiler.py, which:</p> <p>Traverses the AST produced by the parser.</p> <p>Converts each AST node into corresponding IR components using compile_stmt().</p> <p>Flattens nested arguments (via flatten()) to ensure compatibility with the IR schema.</p> <p>Saves the result as a JSON file (e.g., bell_ir.json).</p>"},{"location":"ir_output/#sample-ir-output-bell-state","title":"Sample IR Output: Bell State","text":"<p>Using the same Bell state program from the AST example we get resulting IR, saved as bell_ir.json, is shown below :</p> <p></p>"},{"location":"ir_output/#explanation-of-ir-structure","title":"Explanation of IR Structure","text":"<p>qubits: Lists all declared qubits (q0, q1).</p> <p>classical: Lists classical bits for measurement outputs (c0, c1).</p> <p>instructions: A sequence of operations:-</p> <p>gate: Specifies quantum gates (h, cx) with their arguments. complexes.  - measure: Maps qubits to classical bits for measurement.</p> <p>control_flow: Empty in this case, as the Bell state program lacks conditional statements.</p>"},{"location":"ir_output/#role-of-ir-in-qucpl","title":"Role of IR in QUCPL","text":"<p>The IR serves as a bridge between the parsed AST and the execution backend (e.g., Qiskit).</p> <p>It enables:</p> <p>Visualization: Circuit diagrams generated from IR using visualize.py.</p> <p>Simulation: Execution on Qiskit\u2019s Aer simulator via simulator.py.</p> <p>Extensibility: Future support for advanced protocols and control structures.</p> <p>The successful generation of bell_ir.json validated the compiler\u2019s ability to produce a structured, executable representation of QUCPL programs.</p>"},{"location":"ir_schema/","title":"QuCPL Intermediate Representation (IR) \u2013 JSON Schema Documentation","text":""},{"location":"ir_schema/#overview","title":"Overview","text":"<p>The QuCPL JSON IR is an intermediate representation used to bridge the abstract syntax tree (AST) and execution or simulation (Qiskit/OpenQASM). It encodes quantum programs in a structured and backend-friendly format.</p> <p>The IR schema was defined in a modular and backend-agnostic JSON format, described in detail in the documentation file ir_schema_docs.md. The core design principles focused on:</p> <p>\u2022 Readability: JSON format allows easy inspection and debugging.</p> <p>\u2022 Structure: Clearly separated fields for quantum instructions, declared qubits, and control flow.</p> <p>\u2022 Extensibility: Support for future constructs like loops and conditionals.</p> <p>\u2022 IR is backend-agnostic and easily convertible to Qiskit, OpenQASM, or a custom simulator.</p> <p>\u2022 Fields like args, qubits, and classical are flattened arrays (not nested lists).</p> <p>\u2022 Control flow is kept separate from gate-level instructions for modular execution.</p> <p>\u2022 JSON structure supports easy debugging, visualization, and export.</p>"},{"location":"ir_schema/#ir-schema-design","title":"IR Schema Design","text":"<p>The Intermediate Representation (IR) is a JSON-based format that captures the essential operations of a quantum program in a structured and extensible way. It is designed to be readable, modular, and independent of any specific quantum backend.</p> <p>The IR consists of the following main fields:</p> <p>\"qubits\": An array listing all declared qubits in the program.</p> <p>\"classical\": An array listing all declared classical bits.</p> <p>\"instructions\": An array of objects, each representing a quantum gate, measurement, or print operation.</p> <p>\"control_flow\": An optional field for handling control flow constructs like if statements.</p> <p>Instruction Types</p> <p>Each instruction in the \"instructions\" array is an object tailored to its operation type:</p> <p>Gate Operations (e.g., Hadamard, CNOT):</p> <p>\"type\": \"gate\"</p> <p>\"name\": the gate name (e.g., \"h\", \"cx\")</p> <p>\"args\": an array of qubit indices or names</p> <p>Measurements:</p> <p>\"type\": \"measure\"</p> <p>\"qubit\": the qubit being measured</p> <p>\"target\": the classical bit to store the measurement result</p> <p>Print Statements:</p> <p>\"type\": \"print\"</p> <p>\"args\": an array of variables or literals to print</p> <p>Control Flow</p> <p>The \"control_flow\" field manages conditional logic, such as if statements, by nesting instructions within a block that executes based on a condition.</p> <p>This design ensures that the IR can represent both simple quantum circuits and more complex programs with classical control flow.</p>"},{"location":"ir_schema/#root-structure","title":"Root Structure","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"qubits\": [ \"q0\", \"q1\", \"q2\" ],\n  \"instructions\": [ ... ],\n  \"control_flow\": [ ... ]\n}\n</code></pre> Field Type Description <code>type</code> <code>string</code> Always <code>\"Program\"</code> <code>qubits</code> <code>array</code> List of declared quantum registers <code>instructions</code> <code>array</code> Sequence of gate, measure, print operations <code>control_flow</code> <code>array</code> High-level control structures (e.g., if, while)"},{"location":"ir_schema/#instructions-block","title":"Instructions Block","text":""},{"location":"ir_schema/#gate-operation","title":"Gate Operation","text":"<pre><code>{\n  \"op\": \"h\",\n  \"args\": [\"q0\"]\n}\n</code></pre> <pre><code>{\n  \"op\": \"cx\",\n  \"args\": [\"q0\", \"q1\"]\n}\n</code></pre> Field Description <code>op</code> Gate name: <code>h</code>, <code>cx</code>, <code>x</code>, <code>z</code>, etc. <code>args</code> List of target qubit IDs (order matters)"},{"location":"ir_schema/#measurement-operation","title":"Measurement Operation","text":"<pre><code>{\n  \"op\": \"measure\",\n  \"qubits\": [\"q0\", \"q1\"],\n  \"classical\": [\"c0\", \"c1\"]\n}\n</code></pre> Field Description <code>op</code> Always <code>\"measure\"</code> <code>qubits</code> Qubit list to be measured <code>classical</code> Classical bit list to store results"},{"location":"ir_schema/#print-operation","title":"Print Operation","text":"<pre><code>{\n  \"op\": \"print\",\n  \"args\": [\"c0\", \"c1\"]\n}\n</code></pre> Field Description <code>op</code> Always <code>\"print\"</code> <code>args</code> Variables to print (typically classical bits)"},{"location":"ir_schema/#control-flow-block","title":"Control Flow Block","text":""},{"location":"ir_schema/#if-statement","title":"If Statement","text":"<pre><code>{\n  \"type\": \"if\",\n  \"condition\": {\n    \"type\": \"Condition\",\n    \"var\": \"c0\",\n    \"value\": 1\n  },\n  \"then\": [\n    { \"op\": \"print\", \"args\": [\"c0\"] }\n  ],\n  \"else\": [\n    { \"op\": \"print\", \"args\": [\"c1\"] }\n  ]\n}\n</code></pre> Field Description <code>type</code> <code>\"if\"</code> <code>condition</code> See Condition Structure <code>then</code> Instruction list if condition is true <code>else</code> (Optional) Instruction list if condition is false"},{"location":"ir_schema/#while-statement","title":"While Statement","text":"<pre><code>{\n  \"type\": \"while\",\n  \"condition\": {\n    \"type\": \"Condition\",\n    \"var\": \"c1\",\n    \"value\": 0\n  },\n  \"body\": [\n    { \"op\": \"h\", \"args\": [\"q0\"] }\n  ]\n}\n</code></pre> Field Description <code>type</code> <code>\"while\"</code> <code>condition</code> See Condition Structure <code>body</code> Instruction list to repeat"},{"location":"ir_schema/#condition-structure","title":"Condition Structure","text":"<pre><code>{\n  \"type\": \"Condition\",\n  \"var\": \"c0\",\n  \"value\": 1\n}\n</code></pre> Field Description <code>type</code> <code>\"Condition\"</code> <code>var</code> Classical bit or variable <code>value</code> Integer value to compare against"},{"location":"ir_schema/#full-example","title":"Full Example","text":"<pre><code>{\n  \"type\": \"Program\",\n  \"qubits\": [\"q0\", \"q1\"],\n  \"instructions\": [\n    { \"op\": \"h\", \"args\": [\"q0\"] },\n    { \"op\": \"cx\", \"args\": [\"q0\", \"q1\"] },\n    {\n      \"op\": \"measure\",\n      \"qubits\": [\"q0\", \"q1\"],\n      \"classical\": [\"c0\", \"c1\"]\n    },\n    {\n      \"op\": \"print\",\n      \"args\": [\"c0\", \"c1\"]\n    }\n  ],\n  \"control_flow\": [\n    {\n      \"type\": \"if\",\n      \"condition\": { \"type\": \"Condition\", \"var\": \"c0\", \"value\": 1 },\n      \"then\": [ { \"op\": \"print\", \"args\": [\"c0\"] } ],\n      \"else\": [ { \"op\": \"print\", \"args\": [\"c1\"] } ]\n    }\n  ]\n}\n</code></pre>"},{"location":"language_design/","title":"Defining a Custom Language for Quantum Computing","text":"<p>Building on the conceptual and practical insights gained in Week 1, Week 2 marked the transition from using an existing quantum toolkit (Qiskit) to creating a custom quantum programming language\u2014named QuCPL (Quantum Computing Programming Language). This language is designed to allow developers to write high-level, human-readable quantum code that can be translated into backend instructions for execution or simulation.</p>"},{"location":"language_design/#the-motivation-behind-designing-qucpl-stems-from-the-need-for-a","title":"The motivation behind designing QuCPL stems from the need for: a","text":"<p>\u2022 A readable and intuitive syntax for expressing quantum operations.</p> <p>\u2022 Abstraction over complex circuit-level programming.</p> <p>\u2022 Integration with existing quantum toolkits like Qiskit through an intermediate representation.</p>"},{"location":"language_design/#example-program-bell-state-in-qucpl","title":"Example Program: Bell State in QuCPL","text":"<p>To validate the language and parser, a Bell state program was written in QuCPL syntax:</p> <p></p> <p>\u2022 Declares two quantum bits (qubits): q0 and q1.</p> <p>\u2022 These are initialized in the |0\u27e9 state by default.</p> <p>\u2022 Applies the Hadamard gate (H) to q0.</p> <p>\u2022 This transforms q0 into a superposition state.</p> <p>\u2022 Applies the Controlled-NOT (CNOT) gate: Control: q0 and Target: q1</p> <p>\u2022 This entangles q0 and q1.</p> <p>\u2022 After this, the qubits are in the Bell state:  </p> <p>\u2022 Measures qubits q0 and q1.</p> <p>\u2022 Stores the results in classical bits c0 and c1.</p> <p>\u2022 Outputs the measurement results of c0 and c1.</p>"},{"location":"parser/","title":"Parser Implementation","text":"<p>This section details the design and implementation of the parser for the Quantum Computing Programming Language (QUCPL), a critical component developed during Week 3 of the internship at Quinfo Systems Pvt. Ltd, Hyderabad. The parser transforms QUCPL source code into an Abstract Syntax Tree (AST), enabling further compilation and execution. Built using Lark, a Python-based parsing library, the parser leverages a Parsing Expression Grammar (PEG) to define QUCPL's syntax, ensuring robust and accurate processing of quantum programs.</p>"},{"location":"parser/#objectives","title":"Objectives","text":"<p>The goals for the parser implementation, as outlined in the internship report, were:</p> <p>Define a formal grammar for QUCPL using Lark's PEG syntax.</p> <p>Implement a parser in Python to process QUCPL code and produce an AST.</p> <p>Test the parser with a sample quantum program (e.g., Bell state).</p> <p>Save the AST as a JSON file for compatibility with subsequent compilation stages.</p>"},{"location":"parser/#key-components","title":"Key Components","text":"<p>\u2022 Parser Initialization: The parser is initialized with the Lark grammar file and configured to use the lalr parsing algorithm for efficiency.</p> <p>\u2022 AST Builder (Transformer): The ASTBuilder class, a subclass of Lark\u2019s Transformer, walks the parse tree and constructs a simplified AST.</p> <p>\u2022 Main parser function: Parses the code to get a parse tree and then transforms it into an AST using ASTBuilder.</p> <p>\u2022 Main function:Reads multiple lines of user input for the program code. Stops when the user enters a blank line. Parses the user\u2019s code into an AST and saves it to Json format.</p> <p></p>"},{"location":"parser/#expected-output","title":"Expected Output","text":"<p>The parser successfully validates the syntax.</p> <p>The AST reflects the program\u2019s structure: qubit declarations, Hadamard gate, CNOT gate, measurements, and a comment.</p> <p>The output is saved as ast.json, ready for the compiler to generate an Intermediate Representation (IR).</p> <p>The QUCPL parser, built with Lark and Python, successfully transforms quantum source code into a structured AST, enabling further compilation and execution. Its design reflects a balance between simplicity, robustness, and extensibility, making it a vital part of the QUCPL toolchain. The successful parsing of the Bell state program demonstrates its correctness and sets the stage for advanced quantum protocols like teleportation.</p>"},{"location":"quantum_foundations/","title":"Quantum Foundations","text":"<p>The first week of the internship focused on building a strong foundation in quantum computing concepts while gaining hands-on experience with the Qiskit framework developed by IBM. The specific learning objectives for this phase were:</p> <p>\u2022 To understand the principles of quantum mechanics relevant to computing, such as superposition, entanglement, measurement, and quantum gates.</p> <p>\u2022 To explore how quantum information is represented using qubits and how quantum logic gates manipulate quantum states.</p> <p>\u2022 To get familiar with Qiskit\u2019s environment, syntax, and tools for creating and simulating quantum circuits.</p> <p>\u2022 To implement a basic quantum program\u2014namely, the Bell state circuit\u2014as a proof of concept.</p> <p>\u2022 To produce a short technical report titled \u201cWhat is a Qubit?\u201d for reinforcing understanding and documentation.</p>"},{"location":"quantum_foundations/#introduction-to-quantum-computing","title":"Introduction to QUANTUM COMPUTING","text":"<p>\u2022 Quantum Computing is a field of computing that uses the principles of quantum mechanics\u2014the physics of subatomic particles\u2014to process information.</p> <p>\u2022 Instead of bits, it uses qubits, which can exist in multiple states at once due to quantum phenomena like superposition and entanglement.</p> <p>\u2022 Quantum Computing uses the laws of quantum mechanics to enable massive parallelism and new ways to solve complex problems  that are currently infeasible for classical computers.</p> <p>\u2022 Can evaluate many possibilities simultaneously.</p> <p>\u2022 Offers exponential speedups for certain tasks.</p> <p>\u2022 Outputs are probabilistic, not fixed, and require multiple runs to determine likely results.</p> <p>\u2022 Classical Bit: 0 and 1     Quantum Qubit: |\u03c8\u27e9= \u03b1|0\u27e9+ \u03b2|1\u27e9 (\u03b1 and \u03b2 are complex numbers, |\u03b1|\u00b2 + |\u03b2|\u00b2 = 1)</p> <p>\u2022 Applications of Quantum Computing : Cryptography, Simulating molecules and interactions, AI &amp; ML models, Optimization, etc.</p>"},{"location":"quantum_foundations/#qubit","title":"Qubit","text":"<p>The Building Block of Quantum Computing</p> <p>A qubit (quantum bit) is the basic unit of quantum information, distinct from a classical bit. Unlike a classical bit, which is either 0 or 1, a qubit can exist in a superposition of both states at once, enabling quantum computers to tackle certain problems far more efficiently than classical systems.</p> <p>The state of a qubit is expressed mathematically as: |\u03c8\u27e9= \u03b1|0\u27e9+ \u03b2|1</p> <p>where: alpha, beta are complex probability amplitudes.</p> <p>( |\u03b1|^2 ) and ( |\u03b2|^2 ) represent the probabilities of measuring 0 or 1, respectively.</p> <p>The condition ( |\u03b1|^2 + |\u03b2|^2 = 1 ) ensures normalization.</p>"},{"location":"quantum_foundations/#bloch-sphere","title":"Bloch Sphere","text":"<p>Visualizing Qubits</p> <p>The Bloch sphere offers a visual representation of a qubit\u2019s state, aiding in the comprehension of quantum operations.</p> <p></p> <p>Coordinates: A Bloch vector  defines the qubit\u2019s state.</p> <p>Angles: theta, polar, and phi (azimuthal) position the state on the sphere.</p> <p>This tool is invaluable for visualizing how quantum gates manipulate qubit states through rotations.</p>"},{"location":"quantum_foundations/#quantum-gates-and-circuits","title":"Quantum Gates and Circuits","text":"<p>Quantum gates, the counterparts to classical logic gates, are unitary operations that manipulate qubits reversibly.</p> <p>Common Quantum Gates:</p> <p>Hadamard Gate (H): Generates superposition.</p> <p>Pauli-X Gate (X): Flips the qubit state (e.g., ( |0\\rangle ) to ( |1\\rangle )).</p> <p>Pauli-Y Gate (Y): Rotates the state by \u03c0 radians around the Y-axis.</p> <p>Pauli-Z Gate (Z): Introduces a phase flip, altering the sign of ( |1\\rangle ).</p> <p>CNOT Gate: Flips the target qubit based on the control qubit\u2019s state.</p> <p></p> <p>These gates are critical for building quantum circuits and were integrated into QUCPL.</p> <p>Example:</p> <p>Bell State Circuit in Qiskit Below is a Qiskit implementation of a Bell state circuit to illustrate entanglement:</p> <p>Steps Explained:</p> <p>Hadamard Gate: Creates superposition on qubit 0.</p> <p>CNOT Gate: Entangles qubits 0 and 1.</p> <p>Measurement: Yields outcomes 00 or 11 with equal probability, confirming entanglement.</p>"},{"location":"quantum_foundations/#example-codes","title":"Example codes","text":""},{"location":"quantum_foundations/#summary","title":"Summary","text":"<p>The concepts of qubits, superposition, entanglement, and quantum gates form the bedrock of quantum computing and QUCPL\u2019s functionality. Practical examples like the Bell state circuit demonstrate how these principles translate into real-world applications, paving the way for deeper quantum programming advancements.</p>"},{"location":"references/","title":"References","text":"<p>[1] IBM Quantum, IBM Quantum Documentation. [Online]. Available: https://docs.quantum.ibm.com/. (Used for understanding quantum gates, circuits, backend integration, and simulation workflows with Qiskit.)</p> <p>[2] Qiskit Contributors, Qiskit: An Open-source Framework for Quantum Computing, 2024. [Online]. Available: https://qiskit.org. (Official library used for constructing and executing Bell, GHZ, and teleportation circuits.)</p> <p>[3] Lark Developers, Lark: A Modern Parsing Library for Python. [Online]. Available: https://lark-parser.readthedocs.io/en/latest/. (Used in Weeks 2\u20133 for grammar definition, parsing, and AST generation in QuCPL.)</p> <p>[4] Python Software Foundation, Python 3.11 Documentation. [Online]. Available: https://docs.python.org/3/. (Referenced throughout the project for JSON handling, modular code design, file operations, and error handling.)</p> <p>[5] QuEDX, Quantum Computing Interactive Simulator and Learning Platform. [Online]. Available: https://quedx.com/. (Used in Weeks 1\u20132 for intuitive visualization of quantum operations and circuits.)</p> <p>[6] Wikipedia Contributors, \u201cQubit\u201d, Wikipedia: The Free Encyclopedia. [Online]. Available: https://en.wikipedia.org/wiki/Qubit. (Consulted during technical report writing for definitions and diagrams on quantum states.)</p> <p>[7] MkDocs Team, MkDocs \u2013 Project Documentation Generator. [Online]. Available: https://www.mkdocs.org/. (Used in Week 7 to build the QuCPL documentation site.)</p> <p>[8] OBS Studio Contributors, OBS Studio: Open Source Screen Recorder. [Online]. Available: https://obsproject.com/. (Used for creating video tutorials and walkthroughs.)</p> <p>[9] Loom, Inc., Loom \u2013 Video Messaging for Work. [Online]. Available: https://www.loom.com/. (Used alongside OBS to record short tutorials and visual explanations of QuCPL features.)</p>"},{"location":"simulator/","title":"Quantum Simulation in QUCPL","text":"<p>The simulator implemented in the simulator.py script, serves as a critical component of the QUCPL toolchain, enabling the execution of quantum programs by translating the Intermediate Representation (IR) into executable Qiskit circuits and producing meaningful outputs such as measurement counts, statevectors, and histograms.</p>"},{"location":"simulator/#overview","title":"Overview","text":"<p>The primary objective of Week 5 was to integrate the QUCPL Intermediate Representation (IR) with Qiskit\u2019s backend for circuit execution and simulation. This phase completed the end-to-end pipeline, allowing programs written in QUCPL to be parsed, compiled, and simulated to produce runtime results. The simulator supports a variety of quantum operations, validates program correctness, and provides visual and textual outputs for debugging and analysis.</p>"},{"location":"simulator/#the-key-tasks-accomplished","title":"The key tasks accomplished","text":"<p>Loading and parsing JSON-based IR files.</p> <p>Translating IR instructions into Qiskit-compatible quantum circuits.</p> <p>Executing simulations using Qiskit\u2019s Aer simulator with 1024 shots.</p> <p>Generating measurement results, histograms missingshot histograms, and runtime logs.</p> <p>Implementing error handling for robust operation.</p>"},{"location":"simulator/#simulator-design-and-implementation","title":"Simulator Design and Implementation","text":"<p>The simulator.py script is the core of the QUCPL simulation pipeline, performing three main functions: IR loading and parsing, IR-to-Qiskit circuit translation, and simulation with output generation.</p> <p></p> <p>The simulator begins by loading a JSON-based IR file (e.g., bell_ir.json) generated by the QUCPL compiler. The script validates the IR structure to ensure it contains the expected fields, such as declared qubits, classical bits, and instructions. This step ensures compatibility with Qiskit\u2019s execution environment.</p> <p>The build_qiskit_circuit(ir) function translates the IR into a Qiskit QuantumCircuit object. It performs the following steps:</p> <p>Maps declared qubits and classical bits from the IR to Qiskit\u2019s indexing system.</p> <p>Iterates through the IR\u2019s instruction list, applying operations like Hadamard (h), Controlled-NOT (cx), and measurement (measure) to the circuit.</p> <p>Validates the number of arguments for each gate (e.g., cx requires two qubits).</p> <p>Logs gate usage statistics via a gate_counts dictionary for debugging and optimization insights.</p> <p>Reports errors for unrecognized operations or invalid inputs.</p> <p>The simulate() function compiles the quantum circuit using Qiskit\u2019s transpile function and executes it on the aer_simulator backend.</p> <p>The simulator supports a wide range of quantum gates, including:</p> <p>Single-qubit gates: Hadamard (h), Pauli-X (x), Pauli-Y (y), Pauli-Z (z), rotations (rx, ry, rz).</p> <p>Multi-qubit gates: Controlled-NOT (cx).</p> <p>Measurement operations and statevector computation.</p>"},{"location":"simulator/#the-simulator-was-tested-using-the-bell-state-programs-ir-bell_irjson","title":"The simulator was tested using the Bell state program\u2019s IR (bell_ir.json)","text":"<p>Running simulator.py on bell_ir.json produced:</p> <p></p> <p>Measurement Results: Approximately equal probabilities for states 00 and 11 (around 50% each), confirming the expected entangled distribution of a Bell state.</p> <p>Histogram: A visual representation of the measurement outcomes, saved as histogram.png.</p> <p>Backend Runtime Logs:</p> <p>Backend: aer_simulator Gate Counts: {'h': 1, 'cx': 1, 'measure': 2} Measurement Results: {'00': 512, '11': 512}</p> <p>These results validated the correctness of the QUCPL pipeline, from parsing to simulation, ensuring that the Bell state\u2019s entanglement was accurately represented and executed. Key Features</p>"},{"location":"simulator/#robust-error-handling","title":"Robust Error Handling","text":"<p>The simulator checks for invalid gate arguments, undefined qubits, and unrecognized operations, logging errors like:</p> <p>[ARGUMENT ERROR] Gate 'cx' expects 2 arguments.</p> <p>[RUNTIME ERROR] Unknown qubit 'q3' in instruction.</p> <p>[SIMULATION ERROR] Backend unavailable.</p> <p>Modularity:</p> <p>The code is structured to support additional gates and future extensions like control flow or custom protocols. Visualization: Integration with Matplotlib for histogram generation aids in debugging and understanding quantum outcomes. Performance Tracking: Gate usage statistics and runtime logs provide insights into program efficiency and structure.</p> <p>The QUCPL simulator is a robust tool that translates high-level quantum programs into executable circuits, providing both educational and practical value. By integrating with Qiskit, it enables users to experiment with quantum computing concepts like entanglement and superposition in a user-friendly manner. The successful simulation of the Bell state demonstrates the reliability of the pipeline, setting the stage for further development and real-world applications.</p>"},{"location":"teleportation/","title":"Teleportation Protocol in QUCPL","text":""},{"location":"teleportation/#overview","title":"Overview","text":"<p>This protocol tests QUCPL\u2019s ability to manage quantum gate logic, classical communication, and conditional execution. The week focused on integrating all components developed in prior weeks\u2014parsing, Abstract Syntax Tree (AST) and Intermediate Representation (IR) generation, backend integration, circuit visualization, and simulation\u2014into a robust pipeline capable of executing complex quantum protocols. This effort validated QUCPL\u2019s potential for applications in quantum communication and cryptography.</p>"},{"location":"teleportation/#theoretical-background","title":"Theoretical Background","text":"<p>Quantum teleportation enables the transfer of a quantum state from one qubit to another without physical transmission, leveraging entanglement and classical communication. It adheres to the no-cloning theorem, ensuring the original state is destroyed during the process. The protocol, as implemented in QUCPL, involves:</p> <p>Qubit Setup: Qubit q0 holds the input state Alice\u2019s message qubit. Qubits q1 and q2 form an entangled pair shared between Alice q1 and Bob q2.</p> <p>Entanglement Stage: A Hadamard gate H on q1 creates superposition, followed by a CNOT gate between q1 control and q2 target, producing a Bell state.</p> <p>Bell Measurement: Alice applies a CNOT gate with q0 as control and q1 as target, followed by a Hadamard gate on q0 . Both q0 and q1 are measured into classical bits c0 and c1, collapsing their states and generating two classical bits.</p> <p>Conditional Recovery:</p> <p>Bob uses the classical bits ( c0 ) and ( c1 ) to apply corrective gates to ( q2 ):</p> <p>( c0 = 0, c1 = 0 ): No correction.</p> <p>( c0 = 0, c1 = 1 ): Apply ( X ) gate (bit-flip).</p> <p>( c0 = 1, c1 = 0 ): Apply ( Z ) gate (phase-flip).</p> <p>( c0 = 1, c1 = 1 ): Apply ( Z ) followed by ( X ).</p> <p>These corrections reconstruct the original state on ( q2 ).</p> <p>Final Measurement: Bob measures ( q2 ) into classical bit ( c2 ) to verify the teleported state matches ( q0 )\u2019s initial state.</p> <p>This process relies on entanglement as a resource and two classical bits for communication, making it a cornerstone of quantum information protocols.</p>"},{"location":"teleportation/#implementation-in-qucpl","title":"Implementation in QUCPL","text":"<p>The teleportation protocol was implemented in QUCPL using a clear, modular syntax in the teleportation.qucpl program. Key components include:</p> <p></p> <p>Qubit and Classical Bit Declarations:</p> <p>Qubits: qubit q0, q1, q2;</p> <p>Classical bits: c0, c1, c2 for measurements and control.</p> <p>Entanglement Creation:</p> <p>Apply h q1; to put ( q1 ) in superposition.</p> <p>Apply cx q1, q2; to entangle ( q1 ) and ( q2 ).</p> <p>Bell Measurement:</p> <p>Apply cx q0, q1; and h q0;.</p> <p>Measure: measure q0 -&gt; c0; measure q1 -&gt; c1;.</p> <p>Conditional Corrections:</p> <p>Use conditional statements like:</p> <p>if (c0 == 0 &amp;&amp; c1 == 1) { x q2; }</p> <p>if (c0 == 1 &amp;&amp; c1 == 0) { z q2; }</p> <p>if (c0 == 1 &amp;&amp; c1 == 1) { z q2; x q2; }</p> <p>Final Measurement and Output:</p> <p>Measure: measure q2 -&gt; c2;.</p> <p>Log results using print operations.</p> <p>This implementation highlights QUCPL\u2019s ability to express complex quantum protocols in a readable, high-level syntax, suitable for educational and practical applications.</p>"},{"location":"teleportation/#ast-and-ir-generation","title":"AST and IR Generation","text":"<p>The teleportation.qucpl source code was processed through QUCPL\u2019s pipeline:</p> <p>Parsing: parser.py generated an AST (tele_ast.json), capturing the program\u2019s structure.</p> <p>Compilation: compiler.py transformed the AST into an IR (tele_ir.json), which includes:</p> <pre><code>Gate Operations: Hadamard, CNOT, Pauli-X, Pauli-Z.\n\nBarriers: To separate logical phases (entanglement, measurement, correction).\n\nMeasurements: Mapping q0, q1, and q2 to c0, c1, and c2.\n\nControl Flow: Conditional if blocks for corrections based on c0 and c1.\n\nPrint Operations: For logging results.\n</code></pre> <p></p> <p>The IR\u2019s consistency with QUCPL\u2019s schema confirmed the language\u2019s extensibility for quantum-classical control flow, enabling seamless integration with the simulation backend.</p>"},{"location":"teleportation/#visualization","title":"Visualization","text":"<p>The IR (tele_ir.json) was used to generate a circuit diagram via Qiskit and Matplotlib, visualizing the teleportation protocol\u2019s structure:</p> <pre><code>Entanglement of q1 and q2 (Hadamard and CNOT).\n\nBell measurement on q0 and q1 (CNOT, Hadamard, measurements).\n\nConditional corrections on q2 (X and Z gates).\n\nFinal measurement of q2.\n</code></pre> <p></p> <p>This diagram confirms the logical flow and correctness of the implementation.</p>"},{"location":"teleportation/#simulation-results","title":"Simulation Results","text":"<p>The simulation was executed using Qiskit\u2019s Aer simulator with 1024 shots, handling conditional execution, measurement mapping, and runtime logging.</p> <p>Key details include:</p> <pre><code>Backend: Qiskit Aer simulator.\n\nParameters: 1024 shots for probabilistic outcomes.\n\nResults:Measurement of c2 showed a nearly even distribution of 0 and 1, indicating successful teleportation of a superposed state from q0 to q2.\n</code></pre> <p></p> <p>The histogram visualized this distribution, confirming expected quantum behavior.</p> <p>Runtime Logs:</p> <p></p> <p>Included gate counts (e.g., number of h, cx, x, z), execution time, and classical bit values.</p> <p>These results validated QUCPL\u2019s pipeline, from source code to simulation output.</p>"},{"location":"teleportation/#runtime-error-handling","title":"Runtime error handling","text":"<p>The runtime robustness was significantly improved. The simulator backend was extended to include:</p> <p>\u2022 Gate Argument Checks: Each operation now validates the number of arguments (e.g., cx must have 2).</p> <p>\u2022 Name Resolution: Catches undefined qubit or classical bit references.</p> <p>\u2022 Safe Fallbacks: Invalid instructions are logged and skipped without crashing the pipeline.</p> <p>\u2022 Gate Usage Logging: Shows total use of each gate type per program.</p> <p>Error Examples:</p> <p>\u2022 [ARGUMENT ERROR] Gate 'cx' expects 2 arguments.</p> <p>\u2022 [RUNTIME ERROR] Unknown qubit 'q3' in instruction: {...}</p> <p>\u2022 [SIMULATION ERROR] Backend unavailable.</p> <p>These mechanisms ensured smoother development and testing, especially as the language grows to support more complex logic.</p>"},{"location":"teleportation/#conclusions","title":"Conclusions","text":"<p>Implementing quantum teleportation in QUCPL demonstrated the language\u2019s capability to handle sophisticated quantum protocols involving entanglement, measurement, and classical control. The precise ordering of gates and integration of quantum-classical logic tested QUCPL\u2019s robustness, while runtime validation and error handling enhanced reliability. This milestone paves the way for future applications, such as Quantum Key Distribution, and underscores QUCPL\u2019s potential as an educational and practical tool for quantum computing.</p>"},{"location":"visualize/","title":"Circuit Visualization in QUCPL","text":"<p>Circuit visualization is a critical component of the QUCPL (Quantum Computing Programming Language) project, enabling users to inspect and debug quantum programs by rendering their circuit representations. The visualization tool transforms the Intermediate Representation (IR) of a QUCPL program into a visual quantum circuit diagram using Qiskit and Matplotlib, making the program\u2019s logic tangible and intuitive.</p>"},{"location":"visualize/#overview","title":"Overview","text":"<p>The visualization module, implemented in the visualize.py script, bridges the gap between the abstract code written in QUCPL and the concrete quantum circuits executed on backends like Qiskit\u2019s Aer simulator.</p> <p>The primary goals of the visualization pipeline are:</p> <p>Render Quantum Circuits: Generate clear, accurate circuit diagrams from the IR.</p> <p>Support Debugging: Help developers verify the correctness of their programs by visualizing gate operations, measurements, and qubit interactions.</p> <p>Enhance Usability: Provide a visual feedback loop that makes QUCPL accessible to both beginners and advanced users.</p> <p>The visualization process is integrated into the QUCPL toolchain, taking the JSON-based IR (e.g., bell_ir.json) generated by the compiler and producing a circuit diagram that matches the intended quantum logic.</p>"},{"location":"visualize/#visualization-pipeline","title":"Visualization Pipeline","text":"<p>The visualization pipeline involves the following steps:</p> <p>Load the IR: The visualize.py script reads the JSON-based IR file, which contains the program\u2019s structure, including qubit declarations, gate operations, measurements, and control flow.</p> <p>Map Qubits and Classical Bits: The script maps qubit and classical register names from the IR to Qiskit\u2019s indexing system, ensuring compatibility with Qiskit\u2019s QuantumCircuit object.</p> <p>Apply Operations: It iterates through the IR\u2019s instruction list, applying each operation (e.g., Hadamard, CNOT, measurement) to the circuit.</p> <p>Render the Circuit: Using Qiskit\u2019s visualization tools and Matplotlib, the script generates a graphical representation of the circuit.</p> <p>Handle Errors: Unrecognized operations or invalid inputs are logged to aid debugging without crashing the pipeline.</p> <p>This pipeline ensures that QUCPL programs, such as the Bell state or quantum teleportation circuits, are visually represented in a way that aligns with their logical structure.</p>"},{"location":"visualize/#implementation-details","title":"Implementation Details","text":"<p>The visualize.py script is a key deliverable from Week 4, designed to work seamlessly with the IR schema defined in ir_schema_docs.md. Below is the core implementation, adapted from the internship report\u2019s description:</p> <p>visualize.py:</p> <p></p> <p>This script:</p> <p>Loads the IR: Reads a JSON file (e.g., bell_ir.json) and parses it into a Python dictionary.</p> <p>Builds the Circuit: Creates a Qiskit QuantumCircuit object, mapping qubits and classical bits, and applies operations like h (Hadamard), cx (CNOT), and measure.</p> <p>Renders the Diagram: Uses Qiskit\u2019s draw method with Matplotlib to generate and display the circuit diagram, optionally saving it to a file.</p>"},{"location":"visualize/#example-visualizing-the-bell-state-circuit","title":"Example: Visualizing the Bell State Circuit","text":"<p>To validate the visualization tool, the Bell state program was used as a test case. The program, written in QUCPL syntax, declares two qubits (q0, q1), applies a Hadamard gate to q0, a CNOT gate from q0 to q1, and measures both qubits into classical bits (c0, c1).</p> <p>The IR for this program is in bell_ir.json, see IR section.</p> <p>Running visualize.py on bell_ir.json produces the following circuit diagram:</p> <p></p> <p>The diagram shows:</p> <p>A Hadamard gate (H) on q0, creating a superposition. A CNOT gate (CX) from q0 (control) to q1 (target), entangling the qubits. Measurements of q0 and q1 into classical bits c0 and c1.</p> <p>This output matches the expected logic of the Bell state, confirming the correctness of the visualization pipeline. Integration with QUCPL Toolchain</p> <p>This integration allows users to write QUCPL code, compile it to IR, and immediately visualize the resulting circuit, closing the feedback loop for program development and debugging.</p>"},{"location":"visualize/#the-current-visualization-tool-is-functional-but-can-be-improved","title":"The current visualization tool is functional but can be improved","text":"<p>Interactive Visualizer: Develop a web-based interface for drag-and-drop circuit editing using libraries like D3.js or Plotly.</p> <p>Extended Gate Support: Add visualization for additional gates (e.g., rx, ry, rz) and custom multi-qubit gates.</p> <p>Real-Time Feedback: Integrate visualization directly into the QUCPL IDE or GUI for immediate circuit previews during coding.</p> <p>The visualization module is a cornerstone of QUCPL\u2019s usability, transforming abstract code into intuitive circuit diagrams. By leveraging Qiskit and Matplotlib, it provides a powerful tool for debugging, education, and presentation. The successful visualization of the Bell state circuit demonstrates the module\u2019s effectiveness, and its integration with the broader QUCPL toolchain sets the stage for further advancements in quantum programming.</p>"}]}