# Quantum Simulation in QUCPL

The simulator implemented in the simulator.py script, serves as a critical component of the QUCPL toolchain, enabling the execution of quantum programs by translating the Intermediate Representation (IR) into executable Qiskit circuits and producing meaningful outputs such as measurement counts, statevectors, and histograms.

## Overview

The primary objective of Week 5 was to integrate the QUCPL Intermediate Representation (IR) with Qiskit’s backend for circuit execution and simulation. This phase completed the end-to-end pipeline, allowing programs written in QUCPL to be parsed, compiled, and simulated to produce runtime results. The simulator supports a variety of quantum operations, validates program correctness, and provides visual and textual outputs for debugging and analysis.

## The key tasks accomplished

Loading and parsing JSON-based IR files.

Translating IR instructions into Qiskit-compatible quantum circuits.

Executing simulations using Qiskit’s Aer simulator with 1024 shots.

Generating measurement results, histograms missingshot histograms, and runtime logs.

Implementing error handling for robust operation.

## Simulator Design and Implementation

The simulator.py script is the core of the QUCPL simulation pipeline, performing three main functions: IR loading and parsing, IR-to-Qiskit circuit translation, and simulation with output generation.

![alt text](images/simulate.png)

The simulator begins by loading a JSON-based IR file (e.g., bell_ir.json) generated by the QUCPL compiler. The script validates the IR structure to ensure it contains the expected fields, such as declared qubits, classical bits, and instructions. This step ensures compatibility with Qiskit’s execution environment.

The build_qiskit_circuit(ir) function translates the IR into a Qiskit QuantumCircuit object. It performs the following steps:

Maps declared qubits and classical bits from the IR to Qiskit’s indexing system.

Iterates through the IR’s instruction list, applying operations like Hadamard (h), Controlled-NOT (cx), and measurement (measure) to the circuit.

Validates the number of arguments for each gate (e.g., cx requires two qubits).

Logs gate usage statistics via a gate_counts dictionary for debugging and optimization insights.

Reports errors for unrecognized operations or invalid inputs.

The simulate() function compiles the quantum circuit using Qiskit’s transpile function and executes it on the aer_simulator backend.

The simulator supports a wide range of quantum gates, including:

Single-qubit gates: Hadamard (h), Pauli-X (x), Pauli-Y (y), Pauli-Z (z), rotations (rx, ry, rz).

Multi-qubit gates: Controlled-NOT (cx).

Measurement operations and statevector computation.

## The simulator was tested using the Bell state program’s IR (bell_ir.json)

Running simulator.py on bell_ir.json produced:

![alt text](images/bell_sim.png)

Measurement Results: Approximately equal probabilities for states 00 and 11 (around 50% each), confirming the expected entangled distribution of a Bell state.

Histogram: A visual representation of the measurement outcomes, saved as histogram.png.

Backend Runtime Logs:

Backend: aer_simulator
Gate Counts: {'h': 1, 'cx': 1, 'measure': 2}
Measurement Results: {'00': 512, '11': 512}

These results validated the correctness of the QUCPL pipeline, from parsing to simulation, ensuring that the Bell state’s entanglement was accurately represented and executed.
Key Features

## Robust Error Handling

The simulator checks for invalid gate arguments, undefined qubits, and unrecognized operations, logging errors like:

[ARGUMENT ERROR] Gate 'cx' expects 2 arguments.

[RUNTIME ERROR] Unknown qubit 'q3' in instruction.

[SIMULATION ERROR] Backend unavailable.

Modularity:

The code is structured to support additional gates and future extensions like control flow or custom protocols.
Visualization: Integration with Matplotlib for histogram generation aids in debugging and understanding quantum outcomes.
Performance Tracking: Gate usage statistics and runtime logs provide insights into program efficiency and structure.

The QUCPL simulator is a robust tool that translates high-level quantum programs into executable circuits, providing both educational and practical value. By integrating with Qiskit, it enables users to experiment with quantum computing concepts like entanglement and superposition in a user-friendly manner. The successful simulation of the Bell state demonstrates the reliability of the pipeline, setting the stage for further development and real-world applications.
